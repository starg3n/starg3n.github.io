var beepbox=function(t){"use strict";
/*!
    Copyright (c) 2012-2022 John Nesky and contributing authors

    Permission is hereby granted, free of charge, to any person obtaining a copy of
    this software and associated documentation files (the "Software"), to deal in
    the Software without restriction, including without limitation the rights to
    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
    of the Software, and to permit persons to whom the Software is furnished to do
    so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
    */class e{}function s(t){let e=0;for(let s=0;s<t.length;s++)e+=t[s];const s=e/t.length;for(let e=0;e<t.length;e++)t[e]-=s;return n(t),t.push(0),new Float32Array(t)}function n(t){let e=0;for(let s=0;s<t.length;s++){const n=t[s];t[s]=e,e+=n}}function i(t){return.5*Math.pow(.5,(e.pulseWidthRange-1-t)*e.pulseWidthStepPower)}function h(t,s,n){let i=e.chipNoises[t].samples;if(null==i){if(i=new Float32Array(e.chipNoiseLength+1),e.chipNoises[t].samples=i,0==t){let t=1;for(let s=0;s<e.chipNoiseLength;s++){i[s]=2*(1&t)-1;let e=t>>1;1==(t+e&1)&&(e+=16384),t=e}}else if(1==t)for(let t=0;t<e.chipNoiseLength;t++)i[t]=2*Math.random()-1;else if(2==t){let t=1;for(let s=0;s<e.chipNoiseLength;s++){i[s]=2*(1&t)-1;let e=t>>1;1==(t+e&1)&&(e+=32768),t=e}}else if(3==t){let t=1;for(let s=0;s<e.chipNoiseLength;s++){i[s]=2*(1&t)-1;let e=t>>1;1==(t+e&1)&&(e+=40),t=e}}else{if(4!=t)throw new Error("Unrecognized drum index: "+t);r(i,e.chipNoiseLength,10,11,1,1,0),r(i,e.chipNoiseLength,11,14,.6578,.6578,0),s(i,e.chipNoiseLength),n(i,1/Math.sqrt(e.chipNoiseLength))}i[e.chipNoiseLength]=i[0]}return i}function r(t,e,s,n,i,r,a){const o=0|Math.pow(2,s),l=Math.min(e>>1,0|Math.pow(2,n)),u=h(0,null,null);let c=0;for(let h=o;h<l;h++){let o=i+(r-i)*(Math.log2(h)-s)/(n-s),l=Math.pow(2,7*(o-1)+1)*o;l*=Math.pow(h/2048,a),c+=l,l*=u[h];const f=.61803398875*h*h*Math.PI*2;t[h]=Math.cos(f)*l,t[e-h]=Math.sin(f)*l}return c}function a(t,s,n){const i=e.rhythms[s].arpeggioPatterns[t-1];return null!=i?i[n%i.length]:n%t}function o(t){const e={};for(let s=0;s<t.length;s++){const n=t[s];n.index=s,e[n.name]=n}const s=t;return s.dictionary=e,s}function l(t){return 0!=(1024&t)}function u(t){return 0!=(2048&t)}function c(t){return 0!=(128&t)}function f(t){return 0!=(256&t)}function p(t){return 0!=(512&t)}function m(t){return 0!=(32&t)}function d(t){return 0!=(8&t)}function M(t){return 0!=(16&t)}function S(t){return 0!=(4&t)}function b(t){return 0!=(2&t)}function y(t){return 0!=(64&t)}function v(t){return 0!=(1&t)}function g(t,e){for(let s=0;s<t.length;s++)t[s]*=e}function I(t){if(!function(t){return!(!t||t&t-1)}(t))throw new Error("FFT array length must be a power of 2.");return Math.round(Math.log(t)/Math.log(2))}function P(t,e){const s=I(e);if(e<4)throw new Error("FFT array length must be at least 4.");for(let n=s-1;n>=2;n--){const s=1<<n,i=s>>1,h=s<<1,r=2*Math.PI/h,a=Math.cos(r),o=Math.sin(r),l=2*a;for(let n=0;n<e;n+=h){const e=n,h=e+i,r=e+s,u=r+i,c=r+s,f=t[e],p=t[r];t[e]=f+p,t[h]*=2,t[r]=f-p,t[u]*=2;let m=a,d=-o,M=1,S=0;for(let s=1;s<i;s++){const n=e+s,i=r-s,h=r+s,a=c-s,o=t[n],u=t[i],f=t[h],p=t[a],b=o-u,y=f+p;t[n]=o+u,t[i]=p-f,t[h]=b*m-y*d,t[a]=y*m+b*d;const v=l*m-M,g=l*d-S;M=m,S=d,m=v,d=g}}}for(let s=0;s<e;s+=4){const e=s+1,n=s+2,i=s+3,h=t[s],r=2*t[e],a=t[n],o=2*t[i],l=h+a,u=h-a;t[s]=l+r,t[e]=l-r,t[n]=u+o,t[i]=u-o}!function(t,e){const s=I(e);if(s>16)throw new Error("FFT array length must not be greater than 2^16.");const n=16-s;for(let s=0;s<e;s++){let e;if(e=(43690&s)>>1|(21845&s)<<1,e=(52428&e)>>2|(13107&e)<<2,e=(61680&e)>>4|(3855&e)<<4,e=(e>>8|(255&e)<<8)>>n,e>s){let n=t[s];t[s]=t[e],t[e]=n}}}(t,e)}e.scales=o([{name:"easy :)",realName:"pentatonic major",flags:[!0,!1,!0,!1,!0,!1,!1,!0,!1,!0,!1,!1]},{name:"easy :(",realName:"pentatonic minor",flags:[!0,!1,!1,!0,!1,!0,!1,!0,!1,!1,!0,!1]},{name:"island :)",realName:"ryukyu",flags:[!0,!1,!1,!1,!0,!0,!1,!0,!1,!1,!1,!0]},{name:"island :(",realName:"pelog selisir",flags:[!0,!0,!1,!0,!1,!1,!1,!0,!0,!1,!1,!1]},{name:"blues :)",realName:"blues major",flags:[!0,!1,!0,!0,!0,!1,!1,!0,!1,!0,!1,!1]},{name:"blues :(",realName:"blues",flags:[!0,!1,!1,!0,!1,!0,!0,!0,!1,!1,!0,!1]},{name:"normal :)",realName:"ionian",flags:[!0,!1,!0,!1,!0,!0,!1,!0,!1,!0,!1,!0]},{name:"normal :(",realName:"aeolian",flags:[!0,!1,!0,!0,!1,!0,!1,!0,!0,!1,!0,!1]},{name:"double harmonic :)",realName:"double harmonic major",flags:[!0,!0,!1,!1,!0,!0,!1,!0,!0,!1,!1,!0]},{name:"double harmonic :(",realName:"double harmonic minor",flags:[!0,!1,!0,!0,!1,!1,!0,!0,!0,!1,!1,!0]},{name:"strange",realName:"whole tone",flags:[!0,!1,!0,!1,!0,!1,!0,!1,!0,!1,!0,!1]},{name:"expert",realName:"chromatic",flags:[!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0]}]),e.keys=o([{name:"C",isWhiteKey:!0,basePitch:12},{name:"C♯",isWhiteKey:!1,basePitch:13},{name:"D",isWhiteKey:!0,basePitch:14},{name:"D♯",isWhiteKey:!1,basePitch:15},{name:"E",isWhiteKey:!0,basePitch:16},{name:"F",isWhiteKey:!0,basePitch:17},{name:"F♯",isWhiteKey:!1,basePitch:18},{name:"G",isWhiteKey:!0,basePitch:19},{name:"G♯",isWhiteKey:!1,basePitch:20},{name:"A",isWhiteKey:!0,basePitch:21},{name:"A♯",isWhiteKey:!1,basePitch:22},{name:"B",isWhiteKey:!0,basePitch:23}]),e.blackKeyNameParents=[-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1],e.tempoMin=30,e.tempoMax=300,e.echoDelayRange=24,e.echoDelayStepTicks=4,e.echoSustainRange=8,e.echoShelfHz=4e3,e.echoShelfGain=Math.pow(2,-.5),e.reverbShelfHz=8e3,e.reverbShelfGain=Math.pow(2,-1.5),e.reverbRange=4,e.reverbDelayBufferSize=16384,e.reverbDelayBufferMask=e.reverbDelayBufferSize-1,e.beatsPerBarMin=3,e.beatsPerBarMax=16,e.barCountMin=1,e.barCountMax=128,e.instrumentCountMin=1,e.layeredInstrumentCountMax=4,e.patternInstrumentCountMax=10,e.partsPerBeat=24,e.ticksPerPart=2,e.rhythms=o([{name:"÷3 (triplets)",stepsPerBeat:3,ticksPerArpeggio:4,arpeggioPatterns:[[0],[0,0,1,1],[0,1,2,1]],roundUpThresholds:[5,12,18]},{name:"÷4 (standard)",stepsPerBeat:4,ticksPerArpeggio:3,arpeggioPatterns:[[0],[0,0,1,1],[0,1,2,1]],roundUpThresholds:[3,9,17,21]},{name:"÷6",stepsPerBeat:6,ticksPerArpeggio:4,arpeggioPatterns:[[0],[0,1],[0,1,2,1]],roundUpThresholds:null},{name:"÷8",stepsPerBeat:8,ticksPerArpeggio:3,arpeggioPatterns:[[0],[0,1],[0,1,2,1]],roundUpThresholds:null},{name:"freehand",stepsPerBeat:24,ticksPerArpeggio:3,arpeggioPatterns:[[0],[0,1],[0,1,2,1]],roundUpThresholds:null}]),e.instrumentTypeNames=["chip","FM","noise","spectrum","drumset","harmonics","PWM","Picked String","supersaw"],e.instrumentTypeHasSpecialInterval=[!0,!0,!1,!1,!1,!0,!1,!1,!1],e.chipBaseExpression=.03375,e.fmBaseExpression=.03,e.noiseBaseExpression=.19,e.spectrumBaseExpression=.3,e.drumsetBaseExpression=.45,e.harmonicsBaseExpression=.025,e.pwmBaseExpression=.04725,e.supersawBaseExpression=.061425,e.pickedStringBaseExpression=.025,e.distortionBaseVolume=.011,e.bitcrusherBaseVolume=.01,e.chipWaves=o([{name:"rounded",expression:.94,samples:s([0,.2,.4,.5,.6,.7,.8,.85,.9,.95,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.95,.9,.85,.8,.7,.6,.5,.4,.2,0,-.2,-.4,-.5,-.6,-.7,-.8,-.85,-.9,-.95,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-.95,-.9,-.85,-.8,-.7,-.6,-.5,-.4,-.2])},{name:"triangle",expression:1,samples:s([1/15,.2,5/15,7/15,.6,11/15,13/15,1,1,13/15,11/15,.6,7/15,5/15,.2,1/15,-1/15,-.2,-5/15,-7/15,-.6,-11/15,-13/15,-1,-1,-13/15,-11/15,-.6,-7/15,-5/15,-.2,-1/15])},{name:"square",expression:.5,samples:s([1,-1])},{name:"1/4 pulse",expression:.5,samples:s([1,-1,-1,-1])},{name:"1/8 pulse",expression:.5,samples:s([1,-1,-1,-1,-1,-1,-1,-1])},{name:"sawtooth",expression:.65,samples:s([1/31,3/31,5/31,7/31,9/31,11/31,13/31,15/31,17/31,19/31,21/31,23/31,25/31,27/31,29/31,1,-1,-29/31,-27/31,-25/31,-23/31,-21/31,-19/31,-17/31,-15/31,-13/31,-11/31,-9/31,-7/31,-5/31,-3/31,-1/31])},{name:"double saw",expression:.5,samples:s([0,-.2,-.4,-.6,-.8,-1,1,-.8,-.6,-.4,-.2,1,.8,.6,.4,.2])},{name:"double pulse",expression:.4,samples:s([1,1,1,1,1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1])},{name:"spiky",expression:.4,samples:s([1,-1,1,-1,1,0])}]),e.chipNoises=o([{name:"retro",expression:.25,basePitch:69,pitchFilterMult:1024,isSoft:!1,samples:null},{name:"white",expression:1,basePitch:69,pitchFilterMult:8,isSoft:!0,samples:null},{name:"clang",expression:.4,basePitch:69,pitchFilterMult:1024,isSoft:!1,samples:null},{name:"buzz",expression:.3,basePitch:69,pitchFilterMult:1024,isSoft:!1,samples:null},{name:"hollow",expression:1.5,basePitch:96,pitchFilterMult:1,isSoft:!0,samples:null}]),e.filterFreqStep=1/4,e.filterFreqRange=34,e.filterFreqReferenceSetting=28,e.filterFreqReferenceHz=8e3,e.filterFreqMaxHz=e.filterFreqReferenceHz*Math.pow(2,e.filterFreqStep*(e.filterFreqRange-1-e.filterFreqReferenceSetting)),e.filterFreqMinHz=8,e.filterGainRange=15,e.filterGainCenter=7,e.filterGainStep=.5,e.filterMaxPoints=8,e.filterTypeNames=["low-pass","high-pass","peak"],e.fadeInRange=10,e.fadeOutTicks=[-24,-12,-6,-3,-1,6,12,24,48,72,96],e.fadeOutNeutral=4,e.drumsetFadeOutTicks=48,e.transitions=o([{name:"normal",isSeamless:!1,continues:!1,slides:!1,slideTicks:3,includeAdjacentPatterns:!1},{name:"interrupt",isSeamless:!0,continues:!1,slides:!1,slideTicks:3,includeAdjacentPatterns:!0},{name:"continue",isSeamless:!0,continues:!0,slides:!1,slideTicks:3,includeAdjacentPatterns:!0},{name:"slide",isSeamless:!0,continues:!1,slides:!0,slideTicks:3,includeAdjacentPatterns:!0},{name:"slide in pattern",isSeamless:!0,continues:!1,slides:!0,slideTicks:3,includeAdjacentPatterns:!1}]),e.vibratos=o([{name:"none",amplitude:0,periodsSeconds:[.14],delayTicks:0},{name:"light",amplitude:.15,periodsSeconds:[.14],delayTicks:0},{name:"delayed",amplitude:.3,periodsSeconds:[.14],delayTicks:37},{name:"heavy",amplitude:.45,periodsSeconds:[.14],delayTicks:0},{name:"shaky",amplitude:.1,periodsSeconds:[.11,.17798,.33],delayTicks:0}]),e.unisons=o([{name:"none",voices:1,spread:0,offset:0,expression:1.4,sign:1},{name:"shimmer",voices:2,spread:.018,offset:0,expression:.8,sign:1},{name:"hum",voices:2,spread:.045,offset:0,expression:1,sign:1},{name:"honky tonk",voices:2,spread:.09,offset:0,expression:1,sign:1},{name:"dissonant",voices:2,spread:.25,offset:0,expression:.9,sign:1},{name:"fifth",voices:2,spread:3.5,offset:3.5,expression:.9,sign:1},{name:"octave",voices:2,spread:6,offset:6,expression:.8,sign:1},{name:"bowed",voices:2,spread:.02,offset:0,expression:1,sign:-1},{name:"piano",voices:2,spread:.01,offset:0,expression:1,sign:.7}]),e.effectNames=["reverb","chorus","panning","distortion","bitcrusher","note filter","echo","pitch shift","detune","vibrato","transition type","chord type"],e.effectOrder=[10,11,7,8,9,5,3,4,2,1,6,0],e.noteSizeMax=3,e.volumeRange=8,e.volumeLogScale=-.5,e.panCenter=4,e.panMax=2*e.panCenter,e.panDelaySecondsMax=5e-4,e.chorusRange=4,e.chorusPeriodSeconds=2,e.chorusDelayRange=.0034,e.chorusDelayOffsets=[[1.51,2.1,3.35],[1.47,2.15,3.25]],e.chorusPhaseOffsets=[[0,2.1,4.2],[3.2,5.3,1]],e.chorusMaxDelay=e.chorusDelayRange*(1+e.chorusDelayOffsets[0].concat(e.chorusDelayOffsets[1]).reduce(((t,e)=>Math.max(t,e)))),e.chords=o([{name:"simultaneous",customInterval:!1,arpeggiates:!1,strumParts:0,singleTone:!1},{name:"strum",customInterval:!1,arpeggiates:!1,strumParts:1,singleTone:!1},{name:"arpeggio",customInterval:!1,arpeggiates:!0,strumParts:0,singleTone:!0},{name:"custom interval",customInterval:!0,arpeggiates:!1,strumParts:0,singleTone:!0}]),e.maxChordSize=4,e.operatorCount=4,e.maxPitchOrOperatorCount=Math.max(e.maxChordSize,e.operatorCount),e.algorithms=o([{name:"1←(2 3 4)",carrierCount:1,associatedCarrier:[1,1,1,1],modulatedBy:[[2,3,4],[],[],[]]},{name:"1←(2 3←4)",carrierCount:1,associatedCarrier:[1,1,1,1],modulatedBy:[[2,3],[],[4],[]]},{name:"1←2←(3 4)",carrierCount:1,associatedCarrier:[1,1,1,1],modulatedBy:[[2],[3,4],[],[]]},{name:"1←(2 3)←4",carrierCount:1,associatedCarrier:[1,1,1,1],modulatedBy:[[2,3],[4],[4],[]]},{name:"1←2←3←4",carrierCount:1,associatedCarrier:[1,1,1,1],modulatedBy:[[2],[3],[4],[]]},{name:"1←3 2←4",carrierCount:2,associatedCarrier:[1,2,1,2],modulatedBy:[[3],[4],[],[]]},{name:"1 2←(3 4)",carrierCount:2,associatedCarrier:[1,2,2,2],modulatedBy:[[],[3,4],[],[]]},{name:"1 2←3←4",carrierCount:2,associatedCarrier:[1,2,2,2],modulatedBy:[[],[3],[4],[]]},{name:"(1 2)←3←4",carrierCount:2,associatedCarrier:[1,2,2,2],modulatedBy:[[3],[3],[4],[]]},{name:"(1 2)←(3 4)",carrierCount:2,associatedCarrier:[1,2,2,2],modulatedBy:[[3,4],[3,4],[],[]]},{name:"1 2 3←4",carrierCount:3,associatedCarrier:[1,2,3,3],modulatedBy:[[],[],[4],[]]},{name:"(1 2 3)←4",carrierCount:3,associatedCarrier:[1,2,3,3],modulatedBy:[[4],[4],[4],[]]},{name:"1 2 3 4",carrierCount:4,associatedCarrier:[1,2,3,4],modulatedBy:[[],[],[],[]]}]),e.operatorCarrierInterval=[0,.04,-.073,.091],e.operatorAmplitudeMax=15,e.operatorFrequencies=o([{name:"1×",mult:1,hzOffset:0,amplitudeSign:1},{name:"~1×",mult:1,hzOffset:1.5,amplitudeSign:-1},{name:"2×",mult:2,hzOffset:0,amplitudeSign:1},{name:"~2×",mult:2,hzOffset:-1.3,amplitudeSign:-1},{name:"3×",mult:3,hzOffset:0,amplitudeSign:1},{name:"4×",mult:4,hzOffset:0,amplitudeSign:1},{name:"5×",mult:5,hzOffset:0,amplitudeSign:1},{name:"6×",mult:6,hzOffset:0,amplitudeSign:1},{name:"7×",mult:7,hzOffset:0,amplitudeSign:1},{name:"8×",mult:8,hzOffset:0,amplitudeSign:1},{name:"9×",mult:9,hzOffset:0,amplitudeSign:1},{name:"11×",mult:11,hzOffset:0,amplitudeSign:1},{name:"13×",mult:13,hzOffset:0,amplitudeSign:1},{name:"16×",mult:16,hzOffset:0,amplitudeSign:1},{name:"20×",mult:20,hzOffset:0,amplitudeSign:1}]),e.envelopes=o([{name:"none",type:1,speed:0},{name:"note size",type:0,speed:0},{name:"punch",type:2,speed:0},{name:"flare 1",type:3,speed:32},{name:"flare 2",type:3,speed:8},{name:"flare 3",type:3,speed:2},{name:"twang 1",type:4,speed:32},{name:"twang 2",type:4,speed:8},{name:"twang 3",type:4,speed:2},{name:"swell 1",type:5,speed:32},{name:"swell 2",type:5,speed:8},{name:"swell 3",type:5,speed:2},{name:"tremolo1",type:6,speed:4},{name:"tremolo2",type:6,speed:2},{name:"tremolo3",type:6,speed:1},{name:"tremolo4",type:7,speed:4},{name:"tremolo5",type:7,speed:2},{name:"tremolo6",type:7,speed:1},{name:"decay 1",type:8,speed:10},{name:"decay 2",type:8,speed:7},{name:"decay 3",type:8,speed:4}]),e.feedbacks=o([{name:"1⟲",indices:[[1],[],[],[]]},{name:"2⟲",indices:[[],[2],[],[]]},{name:"3⟲",indices:[[],[],[3],[]]},{name:"4⟲",indices:[[],[],[],[4]]},{name:"1⟲ 2⟲",indices:[[1],[2],[],[]]},{name:"3⟲ 4⟲",indices:[[],[],[3],[4]]},{name:"1⟲ 2⟲ 3⟲",indices:[[1],[2],[3],[]]},{name:"2⟲ 3⟲ 4⟲",indices:[[],[2],[3],[4]]},{name:"1⟲ 2⟲ 3⟲ 4⟲",indices:[[1],[2],[3],[4]]},{name:"1→2",indices:[[],[1],[],[]]},{name:"1→3",indices:[[],[],[1],[]]},{name:"1→4",indices:[[],[],[],[1]]},{name:"2→3",indices:[[],[],[2],[]]},{name:"2→4",indices:[[],[],[],[2]]},{name:"3→4",indices:[[],[],[],[3]]},{name:"1→3 2→4",indices:[[],[],[1],[2]]},{name:"1→4 2→3",indices:[[],[],[2],[1]]},{name:"1→2→3→4",indices:[[],[1],[2],[3]]}]),e.chipNoiseLength=32768,e.spectrumNoiseLength=32768,e.spectrumBasePitch=24,e.spectrumControlPoints=30,e.spectrumControlPointsPerOctave=7,e.spectrumControlPointBits=3,e.spectrumMax=(1<<e.spectrumControlPointBits)-1,e.harmonicsControlPoints=28,e.harmonicsRendered=64,e.harmonicsRenderedForPickedString=256,e.harmonicsControlPointBits=3,e.harmonicsMax=(1<<e.harmonicsControlPointBits)-1,e.harmonicsWavelength=2048,e.pulseWidthRange=8,e.pulseWidthStepPower=.5,e.supersawVoiceCount=7,e.supersawDynamismMax=6,e.supersawSpreadMax=12,e.supersawShapeMax=6,e.pitchChannelCountMin=1,e.pitchChannelCountMax=10,e.noiseChannelCountMin=0,e.noiseChannelCountMax=5,e.noiseInterval=6,e.pitchesPerOctave=12,e.drumCount=12,e.pitchOctaves=7,e.maxPitch=e.pitchOctaves*e.pitchesPerOctave,e.maximumTonesPerChannel=2*e.maxChordSize,e.justIntonationSemitones=[.5,8/15,9/16,.6,5/8,2/3,32/45,3/4,.8,5/6,8/9,15/16,1,16/15,9/8,1.2,5/4,4/3,45/32,1.5,1.6,5/3,16/9,15/8,2].map((t=>Math.log2(t)*e.pitchesPerOctave)),e.pitchShiftRange=e.justIntonationSemitones.length,e.pitchShiftCenter=e.pitchShiftRange>>1,e.detuneCenter=9,e.detuneMax=2*e.detuneCenter,e.sineWaveLength=256,e.sineWaveMask=e.sineWaveLength-1,e.sineWave=function(){const t=new Float32Array(e.sineWaveLength+1);for(let s=0;s<e.sineWaveLength+1;s++)t[s]=Math.sin(s*Math.PI*2/e.sineWaveLength);return t}(),e.pickedStringDispersionCenterFreq=6e3,e.pickedStringDispersionFreqScale=.3,e.pickedStringDispersionFreqMult=4,e.pickedStringShelfHz=4e3,e.stringSustainRange=15,e.stringDecayRate=.12,e.enableAcousticSustain=!1,e.sustainTypeNames=["bright","acoustic"],e.distortionRange=8,e.bitcrusherFreqRange=14,e.bitcrusherOctaveStep=.5,e.bitcrusherQuantizationRange=8,e.maxEnvelopeCount=12,e.defaultAutomationRange=13,e.instrumentAutomationTargets=o([{name:"none",computeIndex:null,displayName:"none",interleave:!1,isFilter:!1,maxCount:1,effect:null,compatibleInstruments:null},{name:"noteVolume",computeIndex:0,displayName:"note volume",interleave:!1,isFilter:!1,maxCount:1,effect:null,compatibleInstruments:null},{name:"pulseWidth",computeIndex:2,displayName:"pulse width",interleave:!1,isFilter:!1,maxCount:1,effect:null,compatibleInstruments:[6,8]},{name:"stringSustain",computeIndex:3,displayName:"sustain",interleave:!1,isFilter:!1,maxCount:1,effect:null,compatibleInstruments:[7]},{name:"unison",computeIndex:4,displayName:"unison",interleave:!1,isFilter:!1,maxCount:1,effect:null,compatibleInstruments:[0,5,7]},{name:"operatorFrequency",computeIndex:5,displayName:"fm# freq",interleave:!0,isFilter:!1,maxCount:e.operatorCount,effect:null,compatibleInstruments:[1]},{name:"operatorAmplitude",computeIndex:9,displayName:"fm# volume",interleave:!1,isFilter:!1,maxCount:e.operatorCount,effect:null,compatibleInstruments:[1]},{name:"feedbackAmplitude",computeIndex:13,displayName:"fm feedback",interleave:!1,isFilter:!1,maxCount:1,effect:null,compatibleInstruments:[1]},{name:"pitchShift",computeIndex:14,displayName:"pitch shift",interleave:!1,isFilter:!1,maxCount:1,effect:7,compatibleInstruments:null},{name:"detune",computeIndex:15,displayName:"detune",interleave:!1,isFilter:!1,maxCount:1,effect:8,compatibleInstruments:null},{name:"vibratoDepth",computeIndex:16,displayName:"vibrato range",interleave:!1,isFilter:!1,maxCount:1,effect:9,compatibleInstruments:null},{name:"noteFilterAllFreqs",computeIndex:1,displayName:"n. filter freqs",interleave:!1,isFilter:!0,maxCount:1,effect:5,compatibleInstruments:null},{name:"noteFilterFreq",computeIndex:17,displayName:"n. filter # freq",interleave:!1,isFilter:!0,maxCount:e.filterMaxPoints,effect:5,compatibleInstruments:null},{name:"noteFilterGain",computeIndex:null,displayName:"n. filter # vol",interleave:!1,isFilter:!0,maxCount:e.filterMaxPoints,effect:5,compatibleInstruments:null},{name:"supersawDynamism",computeIndex:33,displayName:"dynamism",interleave:!1,isFilter:!1,maxCount:1,effect:null,compatibleInstruments:[8]},{name:"supersawSpread",computeIndex:34,displayName:"spread",interleave:!1,isFilter:!1,maxCount:1,effect:null,compatibleInstruments:[8]},{name:"supersawShape",computeIndex:35,displayName:"saw↔pulse",interleave:!1,isFilter:!1,maxCount:1,effect:null,compatibleInstruments:[8]}]);class D{constructor(){this.t=1,this.i=[void 0],this.h=0,this.o=0,this.l=0}pushFront(t){this.l>=this.t&&this.u(),this.o=this.o-1&this.h,this.i[this.o]=t,this.l++}pushBack(t){this.l>=this.t&&this.u(),this.i[this.o+this.l&this.h]=t,this.l++}popFront(){if(this.l<=0)throw new Error("No elements left to pop.");const t=this.i[this.o];return this.i[this.o]=void 0,this.o=this.o+1&this.h,this.l--,t}popBack(){if(this.l<=0)throw new Error("No elements left to pop.");this.l--;const t=this.o+this.l&this.h,e=this.i[t];return this.i[t]=void 0,e}peakFront(){if(this.l<=0)throw new Error("No elements left to pop.");return this.i[this.o]}peakBack(){if(this.l<=0)throw new Error("No elements left to pop.");return this.i[this.o+this.l-1&this.h]}count(){return this.l}set(t,e){if(t<0||t>=this.l)throw new Error("Invalid index");this.i[this.o+t&this.h]=e}get(t){if(t<0||t>=this.l)throw new Error("Invalid index");return this.i[this.o+t&this.h]}remove(t){if(t<0||t>=this.l)throw new Error("Invalid index");if(t<=this.l>>1){for(;t>0;)this.set(t,this.get(t-1)),t--;this.popFront()}else{for(t++;t<this.l;)this.set(t-1,this.get(t)),t++;this.popBack()}}u(){if(this.t>=1073741824)throw new Error("Capacity too big.");this.t=this.t<<1;const t=this.i,e=new Array(this.t),s=0|this.l,n=0|this.o;for(let i=0;i<s;i++)e[i]=t[n+i&this.h];for(let t=s;t<this.t;t++)e[t]=void 0;this.o=0,this.i=e,this.h=this.t-1}}class F{constructor(){this.a=[1],this.b=[1],this.order=0}linearGain0thOrder(t){this.b[0]=t,this.order=0}lowPass1stOrderButterworth(t){const e=1/Math.tan(.5*t),s=1+e;this.a[1]=(1-e)/s,this.b[1]=this.b[0]=1/s,this.order=1}lowPass1stOrderSimplified(t){const e=2*Math.sin(.5*t);this.a[1]=e-1,this.b[0]=e,this.b[1]=0,this.order=1}highPass1stOrderButterworth(t){const e=1/Math.tan(.5*t),s=1+e;this.a[1]=(1-e)/s,this.b[0]=e/s,this.b[1]=-e/s,this.order=1}highShelf1stOrder(t,e){const s=Math.tan(.5*t),n=Math.sqrt(e),i=(s*n-1)/(s*n+1);this.a[1]=i/1,this.b[0]=(1+i+e*(1-i))/2,this.b[1]=(1+i-e*(1-i))/2,this.order=1}allPass1stOrderInvertPhaseAbove(t){const e=(Math.sin(t)-1)/Math.cos(t);this.a[1]=e,this.b[0]=e,this.b[1]=1,this.order=1}allPass1stOrderFractionalDelay(t){const e=(1-t)/(1+t);this.a[1]=e,this.b[0]=e,this.b[1]=1,this.order=1}lowPass2ndOrderButterworth(t,e){const s=Math.sin(t)/(2*e),n=Math.cos(t),i=1+s;this.a[1]=-2*n/i,this.a[2]=(1-s)/i,this.b[2]=this.b[0]=(1-n)/(2*i),this.b[1]=(1-n)/i,this.order=2}lowPass2ndOrderSimplified(t,e){const s=2*Math.sin(t/2),n=1-1/(2*e),i=n+n/(1-s);this.a[1]=2*s+(s-1)*s*i-2,this.a[2]=(s-1)*(s-s*i-1),this.b[0]=s*s,this.b[1]=0,this.b[2]=0,this.order=2}highPass2ndOrderButterworth(t,e){const s=Math.sin(t)/(2*e),n=Math.cos(t),i=1+s;this.a[1]=-2*n/i,this.a[2]=(1-s)/i,this.b[2]=this.b[0]=(1+n)/(2*i),this.b[1]=-(1+n)/i,this.order=2}highShelf2ndOrder(t,e,s){const n=Math.sqrt(e),i=Math.cos(t),h=n+1,r=n-1,a=.5*Math.sin(t)*Math.sqrt(h/n*(1/s-1)+2),o=2*Math.sqrt(n)*a,l=h-r*i+o;this.a[1]=2*(r-h*i)/l,this.a[2]=(h-r*i-o)/l,this.b[0]=n*(h+r*i+o)/l,this.b[1]=-2*n*(r+h*i)/l,this.b[2]=n*(h+r*i-o)/l,this.order=2}peak2ndOrder(t,e,s){const n=Math.sqrt(e),i=s*t/(n>=1?n:1/n),h=Math.tan(.5*i),r=1+h/n;this.b[0]=(1+h*n)/r,this.b[1]=this.a[1]=-2*Math.cos(t)/r,this.b[2]=(1-h*n)/r,this.a[2]=(1-h/n)/r,this.order=2}}class T{constructor(){this.real=0,this.imag=0,this.denom=1}analyze(t,e){this.analyzeComplex(t,Math.cos(e),Math.sin(e))}analyzeComplex(t,e,s){const n=t.a,i=t.b,h=e,r=-s;let a=i[0]+i[1]*h,o=i[1]*r,l=1+n[1]*h,u=n[1]*r,c=h,f=r;for(let e=2;e<=t.order;e++){const t=c*r+f*h;c=c*h-f*r,f=t,a+=i[e]*c,o+=i[e]*f,l+=n[e]*c,u+=n[e]*f}this.denom=l*l+u*u,this.real=a*l+o*u,this.imag=o*l-a*u}magnitude(){return Math.sqrt(this.real*this.real+this.imag*this.imag)/this.denom}angle(){return Math.atan2(this.imag,this.real)}}class k{constructor(){this.a1=0,this.a2=0,this.b0=1,this.b1=0,this.b2=0,this.a1Delta=0,this.a2Delta=0,this.b0Delta=0,this.b1Delta=0,this.b2Delta=0,this.output1=0,this.output2=0,this.useMultiplicativeInputCoefficients=!1}resetOutput(){this.output1=0,this.output2=0}loadCoefficientsWithGradient(t,e,s,n){if(2!=t.order||2!=e.order)throw new Error;this.a1=t.a[1],this.a2=t.a[2],this.b0=t.b[0],this.b1=t.b[1],this.b2=t.b[2],this.a1Delta=(e.a[1]-t.a[1])*s,this.a2Delta=(e.a[2]-t.a[2])*s,n?(this.b0Delta=Math.pow(e.b[0]/t.b[0],s),this.b1Delta=Math.pow(e.b[1]/t.b[1],s),this.b2Delta=Math.pow(e.b[2]/t.b[2],s)):(this.b0Delta=(e.b[0]-t.b[0])*s,this.b1Delta=(e.b[1]-t.b[1])*s,this.b2Delta=(e.b[2]-t.b[2])*s),this.useMultiplicativeInputCoefficients=n}}function x(t){return 2*Math.atan(.5*t)}const O=1e-24;function L(t,e,s){return s<=(e-=1)?s>=t?s:t:e}function w(t,e,s){if(t<=s&&s<=e)return s;throw new Error(`Value ${s} not in range [${t}, ${e}]`)}const R=[48,49,50,51,52,53,54,55,56,57,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,45,95],B=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,62,62,0,0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,0,0,0,0,63,0,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,0,0,0,0,0];class C{constructor(t,e,s){this.p=[],this.m=0;for(let n=e;n<s;n++){const e=B[t.charCodeAt(n)];this.p.push(e>>5&1),this.p.push(e>>4&1),this.p.push(e>>3&1),this.p.push(e>>2&1),this.p.push(e>>1&1),this.p.push(1&e)}}read(t){let e=0;for(;t>0;)e<<=1,e+=this.p[this.m++],t--;return e}readLongTail(t,e){let s=t,n=e;for(;this.p[this.m++];)s+=1<<n,n++;for(;n>0;)n--,this.p[this.m++]&&(s+=1<<n);return s}readPartDuration(){return this.readLongTail(1,3)}readLegacyPartDuration(){return this.readLongTail(1,2)}readPinCount(){return this.readLongTail(1,0)}readPitchInterval(){return this.read(1)?-this.readLongTail(1,3):this.readLongTail(1,3)}}class A{constructor(){this.M=0,this.p=[]}clear(){this.M=0}write(t,e){for(t--;t>=0;)this.p[this.M++]=e>>>t&1,t--}writeLongTail(t,e,s){if(s<t)throw new Error("value out of bounds");s-=t;let n=e;for(;s>=1<<n;)this.p[this.M++]=1,s-=1<<n,n++;for(this.p[this.M++]=0;n>0;)n--,this.p[this.M++]=s>>>n&1}writePartDuration(t){this.writeLongTail(1,3,t)}writePinCount(t){this.writeLongTail(1,0,t)}writePitchInterval(t){t<0?(this.write(1,1),this.writeLongTail(1,3,-t)):(this.write(1,0),this.writeLongTail(1,3,t))}concat(t){for(let e=0;e<t.M;e++)this.p[this.M++]=t.p[e]}encodeBase64(t){for(let e=0;e<this.M;e+=6){const s=this.p[e]<<5|this.p[e+1]<<4|this.p[e+2]<<3|this.p[e+3]<<2|this.p[e+4]<<1|this.p[e+5];t.push(R[s])}return t}lengthBase64(){return Math.ceil(this.M/6)}}function N(t,e,s){return{interval:t,time:e,size:s}}class E{constructor(t,e,s,n,i=!1){this.pitches=[t],this.pins=[N(0,0,n),N(0,s-e,i?0:n)],this.start=e,this.end=s,this.continuesLastPattern=!1}pickMainInterval(){let t=0,e=0;for(let s=1;s<this.pins.length;s++){const n=this.pins[s-1],i=this.pins[s];if(n.interval==i.interval){const s=i.time-n.time;t<s&&(t=s,e=n.interval)}}if(0==t){let t=0;for(let s=0;s<this.pins.length;s++){const n=this.pins[s];t<n.size&&(t=n.size,e=n.interval)}}return e}clone(){const t=new E(-1,this.start,this.end,e.noteSizeMax);t.pitches=this.pitches.concat(),t.pins=[];for(const e of this.pins)t.pins.push(N(e.interval,e.time,e.size));return t.continuesLastPattern=this.continuesLastPattern,t}getEndPinIndex(t){let e;for(e=1;e<this.pins.length-1&&!(this.pins[e].time+this.start>t);e++);return e}}class V{constructor(){this.notes=[],this.instruments=[0]}cloneNotes(){const t=[];for(const e of this.notes)t.push(e.clone());return t}reset(){this.notes.length=0,this.instruments[0]=0,this.instruments.length=1}toJsonObject(t){const s=[];for(const n of this.notes){const i=[];for(const s of n.pins)i.push({tick:(s.time+n.start)*e.rhythms[t.rhythm].stepsPerBeat/e.partsPerBeat,pitchBend:s.interval,volume:Math.round(100*s.size/3)});const h={pitches:n.pitches,points:i};0==n.start&&(h.continuesLastPattern=n.continuesLastPattern),s.push(h)}const n={notes:s};return t.patternInstruments&&(n.instruments=this.instruments.map((t=>t+1))),n}fromJsonObject(t,s,n,i,h){if(s.patternInstruments)if(Array.isArray(t.instruments)){const i=t.instruments,h=L(e.instrumentCountMin,s.getMaxInstrumentsPerPatternForChannel(n)+1,i.length);for(let t=0;t<h;t++)this.instruments[t]=L(0,n.instruments.length,(0|i[t])-1);this.instruments.length=h}else this.instruments[0]=L(0,n.instruments.length,(0|t.instrument)-1),this.instruments.length=1;if(t.notes&&t.notes.length>0){const n=Math.min(s.beatsPerBar*e.partsPerBeat,t.notes.length>>>0);let r=0;for(let a=0;a<t.notes.length&&!(a>=n);a++){const n=t.notes[a];if(!(n&&n.pitches&&n.pitches.length>=1&&n.points&&n.points.length>=2))continue;const o=new E(0,0,0,0);o.pitches=[],o.pins=[];for(let t=0;t<n.pitches.length;t++){const s=0|n.pitches[t];if(-1==o.pitches.indexOf(s)&&(o.pitches.push(s),o.pitches.length>=e.maxChordSize))break}if(o.pitches.length<1)continue;let l=r,u=0;for(let t=0;t<n.points.length;t++){const h=n.points[t];if(null==h||null==h.tick)continue;const r=null==h.pitchBend?0:0|h.pitchBend,a=Math.round(+h.tick*e.partsPerBeat/i),c=null==h.volume?3:Math.max(0,Math.min(3,Math.round(3*(0|h.volume)/100)));if(!(a>s.beatsPerBar*e.partsPerBeat)){if(0==o.pins.length){if(a<l)continue;o.start=a,u=r}else if(a<=l)continue;l=a,o.pins.push(N(r-u,a-o.start,c))}}if(o.pins.length<2)continue;o.end=o.pins[o.pins.length-1].time+o.start;const c=h?e.drumCount-1:e.maxPitch;let f=c,p=0;for(let t=0;t<o.pitches.length;t++)o.pitches[t]+=u,(o.pitches[t]<0||o.pitches[t]>c)&&(o.pitches.splice(t,1),t--),o.pitches[t]<f&&(f=o.pitches[t]),o.pitches[t]>p&&(p=o.pitches[t]);if(!(o.pitches.length<1)){for(let t=0;t<o.pins.length;t++){const e=o.pins[t];e.interval+f<0&&(e.interval=-f),e.interval+p>c&&(e.interval=c-p),t>=2&&e.interval==o.pins[t-1].interval&&e.interval==o.pins[t-2].interval&&e.size==o.pins[t-1].size&&e.size==o.pins[t-2].size&&(o.pins.splice(t-1,1),t--)}0==o.start?o.continuesLastPattern=!0===n.continuesLastPattern:o.continuesLastPattern=!1,this.notes.push(o),r=o.end}}}}}class z{constructor(t){this.frequency=0,this.amplitude=0,this.reset(t)}reset(t){this.frequency=0,this.amplitude=t<=1?e.operatorAmplitudeMax:0}}class W{constructor(t){this.spectrum=[],this.hash=-1,this.reset(t)}reset(t){for(let s=0;s<e.spectrumControlPoints;s++)if(t)this.spectrum[s]=Math.round(e.spectrumMax*(1/Math.sqrt(1+s/3)));else{const t=0==s||7==s||11==s||14==s||16==s||18==s||21==s||23==s||s>=25;this.spectrum[s]=t?Math.max(0,Math.round(e.spectrumMax*(1-s/30))):0}this.markCustomWaveDirty()}markCustomWaveDirty(){const t=et.fittingPowerOfTwo(e.spectrumMax+2)-1;let s=0;for(const e of this.spectrum)s=s*t+e>>>0;this.hash=s}}class G{constructor(){this.wave=null,this.S=-1}getCustomWave(t,s){if(this.S==t.hash)return this.wave;this.S=t.hash;const n=e.spectrumNoiseLength;null!=this.wave&&this.wave.length==n+1||(this.wave=new Float32Array(n+1));const i=this.wave;for(let t=0;t<n;t++)i[t]=0;const h=[0,1/7,Math.log2(5/4),3/7,Math.log2(1.5),5/7,6/7];function a(t){return s+Math.floor(t/e.spectrumControlPointsPerOctave)+h[(t+e.spectrumControlPointsPerOctave)%e.spectrumControlPointsPerOctave]}let o=1;for(let s=0;s<e.spectrumControlPoints+1;s++){const h=s<=0?0:t.spectrum[s-1],l=s>=e.spectrumControlPoints?t.spectrum[e.spectrumControlPoints-1]:t.spectrum[s],u=a(s-1);let c=a(s);s>=e.spectrumControlPoints&&(c=14+.25*(c-14)),0==h&&0==l||(o+=.02*r(i,n,u,c,h/e.spectrumMax,l/e.spectrumMax,-.5))}return t.spectrum[e.spectrumControlPoints-1]>0&&(o+=.02*r(i,n,14+.25*(a(e.spectrumControlPoints)-14),14,t.spectrum[e.spectrumControlPoints-1]/e.spectrumMax,0,-.5)),P(i,n),g(i,5/(Math.sqrt(n)*Math.pow(o,.75))),i[n]=i[0],i}}class q{constructor(){this.harmonics=[],this.hash=-1,this.reset()}reset(){for(let t=0;t<e.harmonicsControlPoints;t++)this.harmonics[t]=0;this.harmonics[0]=e.harmonicsMax,this.harmonics[3]=e.harmonicsMax,this.harmonics[6]=e.harmonicsMax,this.markCustomWaveDirty()}markCustomWaveDirty(){const t=et.fittingPowerOfTwo(e.harmonicsMax+2)-1;let s=0;for(const e of this.harmonics)s=s*t+e>>>0;this.hash=s}}class j{constructor(){this.wave=null,this.S=-1}getCustomWave(t,s){if(this.S==t.hash&&this.v==s)return this.wave;this.S=t.hash,this.v=s;const i=7==s?e.harmonicsRenderedForPickedString:e.harmonicsRendered,r=e.harmonicsWavelength,a=h(0,null,null);null!=this.wave&&this.wave.length==r+1||(this.wave=new Float32Array(r+1));const o=this.wave;for(let t=0;t<r;t++)o[t]=0;let l=1;for(let s=0;s<i;s++){const n=s+1;let h=s<e.harmonicsControlPoints?t.harmonics[s]:t.harmonics[e.harmonicsControlPoints-1];s>=e.harmonicsControlPoints&&(h*=1-(s-e.harmonicsControlPoints)/(i-e.harmonicsControlPoints));const u=h/e.harmonicsMax;let c=Math.pow(2,h-e.harmonicsMax+1)*Math.sqrt(u);s<e.harmonicsControlPoints&&(l+=c),c*=Math.pow(n,-.25),c*=a[s+589],o[r-n]=c}P(o,r);const u=1/Math.pow(l,.7);for(let t=0;t<o.length;t++)o[t]*=u;return n(o),o[r]=o[0],o}}class U{constructor(){this.freq=0,this.gain=e.filterGainCenter,this.type=2}set(t,e){this.freq=t,this.gain=e}getHz(){return U.getHzFromSettingValue(this.freq)}static getHzFromSettingValue(t){return e.filterFreqReferenceHz*Math.pow(2,(t-e.filterFreqReferenceSetting)*e.filterFreqStep)}static getSettingValueFromHz(t){return Math.log2(t/e.filterFreqReferenceHz)/e.filterFreqStep+e.filterFreqReferenceSetting}static getRoundedSettingValueFromHz(t){return Math.max(0,Math.min(e.filterFreqRange-1,Math.round(U.getSettingValueFromHz(t))))}getLinearGain(t=1){const s=(this.gain-e.filterGainCenter)*e.filterGainStep,n=2==this.type?0:-.5,i=n+(s-n)*t;return Math.pow(2,i)}static getRoundedSettingValueFromLinearGain(t){return Math.max(0,Math.min(e.filterGainRange-1,Math.round(Math.log2(t)/e.filterGainStep+e.filterGainCenter)))}toCoefficients(t,s,n=1,i=1){const h=2*Math.PI*Math.max(e.filterFreqMinHz,Math.min(e.filterFreqMaxHz,n*this.getHz()))/s,r=this.getLinearGain(i);switch(this.type){case 0:t.lowPass2ndOrderButterworth(h,r);break;case 1:t.highPass2ndOrderButterworth(h,r);break;case 2:t.peak2ndOrder(h,r,1);break;default:throw new Error}}getVolumeCompensationMult(){const t=(this.freq-e.filterFreqReferenceSetting)*e.filterFreqStep,s=(this.gain-e.filterGainCenter)*e.filterGainStep;switch(this.type){case 0:const n=Math.pow(2,t)*e.filterFreqReferenceHz/8e3,i=(Math.sqrt(1+4*n)-1)/2,h=Math.log2(i);return Math.pow(.5,.2*Math.max(0,s+1)+Math.min(0,Math.max(-3,.595*h+.35*Math.min(0,s+1))));case 1:return Math.pow(.5,.125*Math.max(0,s+1)+Math.min(0,.3*(-t-Math.log2(e.filterFreqReferenceHz/125))+.2*Math.min(0,s+1)));case 2:const r=t+Math.log2(e.filterFreqReferenceHz/2e3),a=Math.pow(1/(1+Math.pow(r/3,2)),2);return Math.pow(.5,.125*Math.max(0,s)+.1*a*Math.min(0,s));default:throw new Error}}}class K{constructor(){this.controlPoints=[],this.controlPointCount=0,this.reset()}reset(){this.controlPointCount=0}addPoint(t,e,s){let n;this.controlPoints.length<=this.controlPointCount?(n=new U,this.controlPoints[this.controlPointCount]=n):n=this.controlPoints[this.controlPointCount],this.controlPointCount++,n.type=t,n.set(e,s)}toJsonObject(){const t=[];for(let s=0;s<this.controlPointCount;s++){const n=this.controlPoints[s];t.push({type:e.filterTypeNames[n.type],cutoffHz:Math.round(100*n.getHz())/100,linearGain:Math.round(1e4*n.getLinearGain())/1e4})}return t}fromJsonObject(t){if(this.controlPoints.length=0,t)for(const s of t){const t=new U;t.type=e.filterTypeNames.indexOf(s.type),-1==t.type&&(t.type=2),null!=s.cutoffHz?t.freq=U.getRoundedSettingValueFromHz(s.cutoffHz):t.freq=0,null!=s.linearGain?t.gain=U.getRoundedSettingValueFromLinearGain(s.linearGain):t.gain=e.filterGainCenter,this.controlPoints.push(t)}this.controlPointCount=this.controlPoints.length}convertLegacySettings(t,e,s){this.reset();const n=2*Math.asin(.475),i=e>1,h=0==e,r=10==t,a=3==s.type||4==s.type||8==s.type||0==s.type,o=48e3,l=8e3*Math.pow(2,.5*(t-10)),u=Math.min(n,2*Math.PI*l/o);if(1==s.type&&!i&&r);else if(h){const t=3.5,e=u*Math.pow(2,t),s=o*(e/(1+e/Math.PI))/(2*Math.PI),n=U.getRoundedSettingValueFromHz(s),i=U.getHzFromSettingValue(n),h=2*Math.PI*i/o,r=new F;r.lowPass1stOrderSimplified(u);const l=new T;l.analyze(r,h);const c=l.magnitude();let f=Math.log2(c);f=.82*(f+t)-t,a&&(f=Math.min(f,-1));const p=Math.pow(2,f),m=U.getRoundedSettingValueFromLinearGain(p);this.addPoint(0,n,m)}else{const t=.5/(1-.95*Math.sqrt(Math.max(0,e-1)/6)),s=.5/t,n=u+(u*(u/(2*Math.PI*8e3/o)*Math.pow(s,.9)+1)-u)*s;let h;h=a?o*Math.min(n,u*Math.pow(2,.25))/(2*Math.PI):o*n/(2*Math.PI);const r=U.getRoundedSettingValueFromHz(h);let l;if(a)l=t;else{const e=new F;e.lowPass2ndOrderSimplified(u,t);const s=new T;s.analyze(e,n),l=s.magnitude()}i||(l=Math.min(l,Math.sqrt(.5)));const c=U.getRoundedSettingValueFromLinearGain(l);this.addPoint(0,r,c)}}}class H{constructor(){this.target=0,this.index=0,this.envelope=0,this.reset()}reset(){this.target=0,this.index=0,this.envelope=0}toJsonObject(){const t={target:e.instrumentAutomationTargets[this.target].name,envelope:e.envelopes[this.envelope].name};return e.instrumentAutomationTargets[this.target].maxCount>1&&(t.index=this.index),t}fromJsonObject(t){this.reset();let s=e.instrumentAutomationTargets.dictionary[t.target];null==s&&(s=e.instrumentAutomationTargets.dictionary.noteVolume),this.target=s.index;let n=e.envelopes.dictionary[t.envelope];null==n&&(n=e.envelopes.dictionary.none),this.envelope=n.index,null!=t.index?this.index=L(0,e.instrumentAutomationTargets[this.target].maxCount,0|t.index):this.index=0}}class J{constructor(t){this.type=0,this.preset=0,this.chipWave=2,this.chipNoise=1,this.eqFilter=new K,this.noteFilter=new K,this.envelopes=[],this.envelopeCount=0,this.fadeIn=0,this.fadeOut=e.fadeOutNeutral,this.transition=e.transitions.dictionary.normal.index,this.pitchShift=0,this.detune=0,this.vibrato=0,this.unison=0,this.effects=0,this.chord=1,this.volume=0,this.pan=e.panCenter,this.pulseWidth=e.pulseWidthRange-1,this.supersawDynamism=e.supersawDynamismMax,this.supersawSpread=Math.ceil(e.supersawSpreadMax/2),this.supersawShape=0,this.stringSustain=10,this.stringSustainType=1,this.distortion=0,this.bitcrusherFreq=0,this.bitcrusherQuantization=0,this.chorus=0,this.reverb=0,this.echoSustain=0,this.echoDelay=0,this.algorithm=0,this.feedbackType=0,this.feedbackAmplitude=0,this.operators=[],this.harmonicsWave=new q,this.drumsetEnvelopes=[],this.drumsetSpectrumWaves=[],this.spectrumWave=new W(t);for(let t=0;t<e.operatorCount;t++)this.operators[t]=new z(t);for(let t=0;t<e.drumCount;t++)this.drumsetEnvelopes[t]=e.envelopes.dictionary["twang 2"].index,this.drumsetSpectrumWaves[t]=new W(!0)}setTypeAndReset(t,s){switch(this.type=t,this.preset=t,this.volume=0,this.effects=0,this.chorus=e.chorusRange-1,this.reverb=2,this.echoSustain=Math.floor(.5*(e.echoSustainRange-1)),this.echoDelay=Math.floor(.5*(e.echoDelayRange-1)),this.eqFilter.reset(),this.noteFilter.reset(),this.distortion=Math.floor(.75*(e.distortionRange-1)),this.bitcrusherFreq=Math.floor(.5*(e.bitcrusherFreqRange-1)),this.bitcrusherQuantization=Math.floor(.5*(e.bitcrusherQuantizationRange-1)),this.pan=e.panCenter,this.pitchShift=e.pitchShiftCenter,this.detune=e.detuneCenter,this.vibrato=0,this.unison=0,this.stringSustain=10,this.stringSustainType=e.enableAcousticSustain?1:0,this.fadeIn=0,this.fadeOut=e.fadeOutNeutral,this.transition=e.transitions.dictionary.normal.index,this.envelopeCount=0,t){case 0:this.chipWave=2,this.chord=e.chords.dictionary.arpeggio.index;break;case 1:this.chord=e.chords.dictionary["custom interval"].index,this.algorithm=0,this.feedbackType=0,this.feedbackAmplitude=0;for(let t=0;t<this.operators.length;t++)this.operators[t].reset(t);break;case 2:this.chipNoise=1,this.chord=e.chords.dictionary.arpeggio.index;break;case 3:this.chord=e.chords.dictionary.simultaneous.index,this.spectrumWave.reset(s);break;case 4:this.chord=e.chords.dictionary.simultaneous.index;for(let t=0;t<e.drumCount;t++)this.drumsetEnvelopes[t]=e.envelopes.dictionary["twang 2"].index,this.drumsetSpectrumWaves[t].reset(s);break;case 5:this.chord=e.chords.dictionary.simultaneous.index,this.harmonicsWave.reset();break;case 6:this.chord=e.chords.dictionary.arpeggio.index,this.pulseWidth=e.pulseWidthRange-1;break;case 7:this.chord=e.chords.dictionary.strum.index,this.harmonicsWave.reset();break;case 8:this.chord=e.chords.dictionary.arpeggio.index,this.supersawDynamism=e.supersawDynamismMax,this.supersawSpread=Math.ceil(e.supersawSpreadMax/2),this.supersawShape=0,this.pulseWidth=e.pulseWidthRange-1;break;default:throw new Error("Unrecognized instrument type: "+t)}this.chord!=e.chords.dictionary.simultaneous.index&&(this.effects=2048|this.effects)}convertLegacySettings(t){let s=t.filterCutoff,n=t.filterResonance,i=t.filterEnvelope,h=t.pulseEnvelope,r=t.operatorEnvelopes,a=t.feedbackEnvelope;null==s&&(s=0==this.type?6:10),null==n&&(n=0),null==i&&(i=e.envelopes.dictionary.none),null==h&&(h=e.envelopes.dictionary[6==this.type?"twang 2":"none"]),null==r&&(r=[e.envelopes.dictionary[1==this.type?"note size":"none"],e.envelopes.dictionary.none,e.envelopes.dictionary.none,e.envelopes.dictionary.none]),null==a&&(a=e.envelopes.dictionary.none);10==s&&2==i.type&&(i=e.envelopes.dictionary.none);const o=e.algorithms[this.algorithm].carrierCount;let l=!0,u=!0,c=0==i.type||0==h.type;if(1==this.type){c=c||0==a.type;for(let t=0;t<r.length;t++)t<o?0!=r[t].type?u=!1:l=!1:c=c||0==r[t].type}this.envelopeCount=0,1==this.type&&(u&&c?this.addEnvelope(e.instrumentAutomationTargets.dictionary.noteVolume.index,0,e.envelopes.dictionary["note size"].index):l&&!c&&this.addEnvelope(e.instrumentAutomationTargets.dictionary.none.index,0,e.envelopes.dictionary["note size"].index)),1==i.type?(this.noteFilter.reset(),this.eqFilter.convertLegacySettings(s,n,i),this.effects&=-33):(this.eqFilter.reset(),this.noteFilter.convertLegacySettings(s,n,i),this.effects|=32,this.addEnvelope(e.instrumentAutomationTargets.dictionary.noteFilterAllFreqs.index,0,i.index)),1!=h.type&&this.addEnvelope(e.instrumentAutomationTargets.dictionary.pulseWidth.index,0,h.index);for(let t=0;t<r.length;t++)t<o&&u||1!=r[t].type&&this.addEnvelope(e.instrumentAutomationTargets.dictionary.operatorAmplitude.index,t,r[t].index);1!=a.type&&this.addEnvelope(e.instrumentAutomationTargets.dictionary.feedbackAmplitude.index,0,a.index)}toJsonObject(){const t={type:e.instrumentTypeNames[this.type],volume:20*(5-this.volume),eqFilter:this.eqFilter.toJsonObject()};this.preset!=this.type&&(t.preset=this.preset);const s=[];for(const t of e.effectOrder)this.effects&1<<t&&s.push(e.effectNames[t]);if(t.effects=s,l(this.effects)&&(t.transition=e.transitions[this.transition].name),u(this.effects)&&(t.chord=this.getChord().name),c(this.effects)&&(t.pitchShiftSemitones=this.pitchShift),f(this.effects)&&(t.detuneCents=et.detuneToCents(this.detune-e.detuneCenter)),p(this.effects)&&(t.vibrato=e.vibratos[this.vibrato].name),m(this.effects)&&(t.noteFilter=this.noteFilter.toJsonObject()),d(this.effects)&&(t.distortion=Math.round(100*this.distortion/(e.distortionRange-1))),M(this.effects)&&(t.bitcrusherOctave=(e.bitcrusherFreqRange-1-this.bitcrusherFreq)*e.bitcrusherOctaveStep,t.bitcrusherQuantization=Math.round(100*this.bitcrusherQuantization/(e.bitcrusherQuantizationRange-1))),S(this.effects)&&(t.pan=Math.round(100*(this.pan-e.panCenter)/e.panCenter)),b(this.effects)&&(t.chorus=Math.round(100*this.chorus/(e.chorusRange-1))),y(this.effects)&&(t.echoSustain=Math.round(100*this.echoSustain/(e.echoSustainRange-1)),t.echoDelayBeats=Math.round(1e3*(this.echoDelay+1)*e.echoDelayStepTicks/(e.ticksPerPart*e.partsPerBeat))/1e3),v(this.effects)&&(t.reverb=Math.round(100*this.reverb/(e.reverbRange-1))),4!=this.type&&(t.fadeInSeconds=Math.round(1e4*et.fadeInSettingToSeconds(this.fadeIn))/1e4,t.fadeOutTicks=et.fadeOutSettingToTicks(this.fadeOut)),5==this.type||7==this.type){t.harmonics=[];for(let s=0;s<e.harmonicsControlPoints;s++)t.harmonics[s]=Math.round(100*this.harmonicsWave.harmonics[s]/e.harmonicsMax)}if(2==this.type)t.wave=e.chipNoises[this.chipNoise].name;else if(3==this.type){t.spectrum=[];for(let s=0;s<e.spectrumControlPoints;s++)t.spectrum[s]=Math.round(100*this.spectrumWave.spectrum[s]/e.spectrumMax)}else if(4==this.type){t.drums=[];for(let s=0;s<e.drumCount;s++){const n=[];for(let t=0;t<e.spectrumControlPoints;t++)n[t]=Math.round(100*this.drumsetSpectrumWaves[s].spectrum[t]/e.spectrumMax);t.drums[s]={filterEnvelope:this.getDrumsetEnvelope(s).name,spectrum:n}}}else if(0==this.type)t.wave=e.chipWaves[this.chipWave].name,t.unison=e.unisons[this.unison].name;else if(6==this.type)t.pulseWidth=Math.round(100*i(this.pulseWidth)*1e5)/1e5;else if(8==this.type)t.pulseWidth=Math.round(100*i(this.pulseWidth)*1e5)/1e5,t.dynamism=Math.round(100*this.supersawDynamism/e.supersawDynamismMax),t.spread=Math.round(100*this.supersawSpread/e.supersawSpreadMax),t.shape=Math.round(100*this.supersawShape/e.supersawShapeMax);else if(7==this.type)t.unison=e.unisons[this.unison].name,t.stringSustain=Math.round(100*this.stringSustain/(e.stringSustainRange-1)),e.enableAcousticSustain&&(t.stringSustainType=e.sustainTypeNames[this.stringSustainType]);else if(5==this.type)t.unison=e.unisons[this.unison].name;else{if(1!=this.type)throw new Error("Unrecognized instrument type");{const s=[];for(const t of this.operators)s.push({frequency:e.operatorFrequencies[t.frequency].name,amplitude:t.amplitude});t.algorithm=e.algorithms[this.algorithm].name,t.feedbackType=e.feedbacks[this.feedbackType].name,t.feedbackAmplitude=this.feedbackAmplitude,t.operators=s}}const n=[];for(let t=0;t<this.envelopeCount;t++)n.push(this.envelopes[t].toJsonObject());return t.envelopes=n,t}fromJsonObject(t,s,n=0){null==t&&(t={});let i=e.instrumentTypeNames.indexOf(t.type);if(-1==i&&(i=s?2:0),this.setTypeAndReset(i,s),null!=t.preset&&(this.preset=t.preset>>>0),null!=t.volume?this.volume=L(0,e.volumeRange,Math.round(5-(0|t.volume)/20)):this.volume=0,Array.isArray(t.effects)){let s=0;for(let n=0;n<t.effects.length;n++)s|=1<<e.effectNames.indexOf(t.effects[n]);this.effects=4095&s}else{const e=["none","reverb","chorus","chorus & reverb"];this.effects=e.indexOf(t.effects),-1==this.effects&&(this.effects=2==this.type?0:1)}this.transition=e.transitions.dictionary.normal.index;const h=t.transition||t.envelope;if(null!=h){let s=e.transitions.dictionary[h];if(null==t.fadeInSeconds||null==t.fadeOutTicks){const t={binary:{transition:"interrupt",fadeInSeconds:0,fadeOutTicks:-1},seamless:{transition:"interrupt",fadeInSeconds:0,fadeOutTicks:-1},sudden:{transition:"normal",fadeInSeconds:0,fadeOutTicks:-3},hard:{transition:"normal",fadeInSeconds:0,fadeOutTicks:-3},smooth:{transition:"normal",fadeInSeconds:.025,fadeOutTicks:-3},soft:{transition:"normal",fadeInSeconds:.025,fadeOutTicks:-3},slide:{transition:"slide in pattern",fadeInSeconds:.025,fadeOutTicks:-3},"cross fade":{transition:"normal",fadeInSeconds:.04,fadeOutTicks:6},"hard fade":{transition:"normal",fadeInSeconds:0,fadeOutTicks:48},"medium fade":{transition:"normal",fadeInSeconds:.0125,fadeOutTicks:72},"soft fade":{transition:"normal",fadeInSeconds:.06,fadeOutTicks:96}}[h];null!=t&&(s=e.transitions.dictionary[t.transition],this.fadeIn=et.secondsToFadeInSetting(t.fadeInSeconds),this.fadeOut=et.ticksToFadeOutSetting(t.fadeOutTicks))}null!=s&&(this.transition=s.index),this.transition!=e.transitions.dictionary.normal.index&&(this.effects=1024|this.effects)}null!=t.fadeInSeconds&&(this.fadeIn=et.secondsToFadeInSetting(+t.fadeInSeconds)),null!=t.fadeOutTicks&&(this.fadeOut=et.ticksToFadeOutSetting(+t.fadeOutTicks));{const s=t.chord,n={harmony:"simultaneous"},i=e.chords.dictionary[n[s]]||e.chords.dictionary[s];null!=i?this.chord=i.index:2==this.type?this.chord=e.chords.dictionary.arpeggio.index:7==this.type?this.chord=e.chords.dictionary.strum.index:0==this.type?this.chord=e.chords.dictionary.arpeggio.index:1==this.type?this.chord=e.chords.dictionary["custom interval"].index:this.chord=e.chords.dictionary.simultaneous.index}this.unison=e.unisons.dictionary.none.index;const r=t.unison||t.interval||t.chorus;if(null!=r){const t={union:"none",fifths:"fifth",octaves:"octave"},s=e.unisons.dictionary[t[r]]||e.unisons.dictionary[r];null!=s&&(this.unison=s.index)}"custom harmony"==t.chorus&&(this.unison=e.unisons.dictionary.hum.index,this.chord=e.chords.dictionary["custom interval"].index),this.chord==e.chords.dictionary.simultaneous.index||Array.isArray(t.effects)||(this.effects=2048|this.effects),null!=t.pitchShiftSemitones&&(this.pitchShift=L(0,e.pitchShiftRange,Math.round(+t.pitchShiftSemitones))),null!=t.detuneCents&&(this.detune=L(0,e.detuneMax+1,Math.round(e.detuneCenter+et.centsToDetune(+t.detuneCents)))),this.vibrato=e.vibratos.dictionary.none.index;const a=t.vibrato||t.effect;if(null!=a){const t={"vibrato light":"light","vibrato delayed":"delayed","vibrato heavy":"heavy"},s=e.vibratos.dictionary[t[r]]||e.vibratos.dictionary[a];null!=s&&(this.vibrato=s.index),s!=e.vibratos.dictionary.none&&(this.effects=512|this.effects)}if(null!=t.pan?(this.pan=L(0,e.panMax+1,Math.round(e.panCenter+(0|t.pan)*e.panCenter/100)),this.pan!=e.panCenter&&(this.effects=4|this.effects)):this.pan=e.panCenter,null!=t.distortion&&(this.distortion=L(0,e.distortionRange,Math.round((e.distortionRange-1)*(0|t.distortion)/100))),null!=t.bitcrusherOctave&&(this.bitcrusherFreq=e.bitcrusherFreqRange-1-+t.bitcrusherOctave/e.bitcrusherOctaveStep),null!=t.bitcrusherQuantization&&(this.bitcrusherQuantization=L(0,e.bitcrusherQuantizationRange,Math.round((e.bitcrusherQuantizationRange-1)*(0|t.bitcrusherQuantization)/100))),null!=t.echoSustain&&(this.echoSustain=L(0,e.echoSustainRange,Math.round((e.echoSustainRange-1)*(0|t.echoSustain)/100))),null!=t.echoDelayBeats&&(this.echoDelay=L(0,e.echoDelayRange,Math.round(+t.echoDelayBeats*(e.ticksPerPart*e.partsPerBeat)/e.echoDelayStepTicks-1))),isNaN(t.chorus)||(this.chorus=L(0,e.chorusRange,Math.round((e.chorusRange-1)*(0|t.chorus)/100))),null!=t.reverb?this.reverb=L(0,e.reverbRange,Math.round((e.reverbRange-1)*(0|t.reverb)/100)):0==n?this.effects=-2&this.effects:this.reverb=n,null!=t.pulseWidth?this.pulseWidth=L(0,e.pulseWidthRange,Math.round(Math.log2(+t.pulseWidth/50)/.5-1+8)):this.pulseWidth=e.pulseWidthRange-1,null!=t.dynamism?this.supersawDynamism=L(0,e.supersawDynamismMax+1,Math.round(e.supersawDynamismMax*(0|t.dynamism)/100)):this.supersawDynamism=e.supersawDynamismMax,null!=t.spread?this.supersawSpread=L(0,e.supersawSpreadMax+1,Math.round(e.supersawSpreadMax*(0|t.spread)/100)):this.supersawSpread=Math.ceil(e.supersawSpreadMax/2),null!=t.shape?this.supersawShape=L(0,e.supersawShapeMax+1,Math.round(e.supersawShapeMax*(0|t.shape)/100)):this.supersawShape=0,null!=t.harmonics){for(let s=0;s<e.harmonicsControlPoints;s++)this.harmonicsWave.harmonics[s]=Math.max(0,Math.min(e.harmonicsMax,Math.round(e.harmonicsMax*+t.harmonics[s]/100)));this.harmonicsWave.markCustomWaveDirty()}else this.harmonicsWave.reset();if(null!=t.spectrum){for(let s=0;s<e.spectrumControlPoints;s++)this.spectrumWave.spectrum[s]=Math.max(0,Math.min(e.spectrumMax,Math.round(e.spectrumMax*+t.spectrum[s]/100)));this.spectrumWave.markCustomWaveDirty()}else this.spectrumWave.reset(s);null!=t.stringSustain?this.stringSustain=L(0,e.stringSustainRange,Math.round((e.stringSustainRange-1)*(0|t.stringSustain)/100)):this.stringSustain=10,this.stringSustainType=e.enableAcousticSustain?e.sustainTypeNames.indexOf(t.stringSustainType):0,-1==this.stringSustainType&&(this.stringSustainType=0),2==this.type&&(this.chipNoise=e.chipNoises.findIndex((e=>e.name==t.wave)),-1==this.chipNoise&&(this.chipNoise=1));const o={custom:"note size",steady:"none","pluck 1":"twang 1","pluck 2":"twang 2","pluck 3":"twang 3"},l=t=>null!=o[t]?e.envelopes.dictionary[o[t]]:e.envelopes.dictionary[t];if(4==this.type&&null!=t.drums)for(let s=0;s<e.drumCount;s++){const n=t.drums[s];if(null!=n){if(this.drumsetEnvelopes[s]=e.envelopes.dictionary["twang 2"].index,null!=n.filterEnvelope){const t=l(n.filterEnvelope);null!=t&&(this.drumsetEnvelopes[s]=t.index)}if(null!=n.spectrum)for(let t=0;t<e.spectrumControlPoints;t++)this.drumsetSpectrumWaves[s].spectrum[t]=Math.max(0,Math.min(e.spectrumMax,Math.round(e.spectrumMax*+n.spectrum[t]/100)))}}if(0==this.type){const s={triangle:1,square:2,"pulse wide":3,"pulse narrow":4,sawtooth:5,"double saw":6,"double pulse":7,spiky:8,plateau:0};this.chipWave=null!=s[t.wave]?s[t.wave]:e.chipWaves.findIndex((e=>e.name==t.wave)),-1==this.chipWave&&(this.chipWave=1)}if(1==this.type){this.algorithm=e.algorithms.findIndex((e=>e.name==t.algorithm)),-1==this.algorithm&&(this.algorithm=0),this.feedbackType=e.feedbacks.findIndex((e=>e.name==t.feedbackType)),-1==this.feedbackType&&(this.feedbackType=0),null!=t.feedbackAmplitude?this.feedbackAmplitude=L(0,e.operatorAmplitudeMax+1,0|t.feedbackAmplitude):this.feedbackAmplitude=0;for(let s=0;s<e.operatorCount;s++){const n=this.operators[s];let i;null!=t.operators&&(i=t.operators[s]),null==i&&(i={}),n.frequency=e.operatorFrequencies.findIndex((t=>t.name==i.frequency)),-1==n.frequency&&(n.frequency=0),null!=i.amplitude?n.amplitude=L(0,e.operatorAmplitudeMax+1,0|i.amplitude):n.amplitude=0}}if(null!=t.noteFilter?this.noteFilter.fromJsonObject(t.noteFilter):this.noteFilter.reset(),Array.isArray(t.eqFilter))this.eqFilter.fromJsonObject(t.eqFilter);else{this.eqFilter.reset();const s={},n=8e3,i=11,h=8;if(null!=t.filterCutoffHz?s.filterCutoff=L(0,i,Math.round(i-1+2*Math.log((0|t.filterCutoffHz)/n)/Math.LN2)):s.filterCutoff=0==this.type?6:10,null!=t.filterResonance?s.filterResonance=L(0,h,Math.round((h-1)*(0|t.filterResonance)/100)):s.filterResonance=0,s.filterEnvelope=l(t.filterEnvelope),s.pulseEnvelope=l(t.pulseEnvelope),s.feedbackEnvelope=l(t.feedbackEnvelope),Array.isArray(t.operators)){s.operatorEnvelopes=[];for(let n=0;n<e.operatorCount;n++){let i;null!=t.operators[n]&&(i=l(t.operators[n].envelope)),s.operatorEnvelopes[n]=null!=i?i:e.envelopes.dictionary.none}}if(null!=t.filter){const e=[10,6,3,0,8,5,2],n=["none","none","none","none","decay 1","decay 2","decay 3"],i=["none","bright","medium","soft","decay bright","decay medium","decay soft"],h={"sustain sharp":1,"sustain medium":2,"sustain soft":3,"decay sharp":4};let r=null!=h[t.filter]?h[t.filter]:i.indexOf(t.filter);-1==r&&(r=0),s.filterCutoff=e[r],s.filterEnvelope=l(n[r]),s.filterResonance=0}this.convertLegacySettings(s)}if(Array.isArray(t.envelopes)){const s=t.envelopes;for(let t=0;t<s.length&&!(this.envelopeCount>=e.maxEnvelopeCount);t++){const e=new H;e.fromJsonObject(s[t]),this.addEnvelope(e.target,e.index,e.envelope)}}}static frequencyFromPitch(t){return 440*Math.pow(2,(t-69)/12)}addEnvelope(t,s,n){if(!this.supportsEnvelopeTarget(t,s))throw new Error;if(this.envelopeCount>=e.maxEnvelopeCount)throw new Error;for(;this.envelopes.length<=this.envelopeCount;)this.envelopes[this.envelopes.length]=new H;const i=this.envelopes[this.envelopeCount];i.target=t,i.index=s,i.envelope=n,this.envelopeCount++}supportsEnvelopeTarget(t,s){const n=e.instrumentAutomationTargets[t];return(null!=n.computeIndex||"none"==n.name)&&(!(s>=n.maxCount)&&((null==n.compatibleInstruments||-1!=n.compatibleInstruments.indexOf(this.type))&&((null==n.effect||0!=(this.effects&1<<n.effect))&&!(n.isFilter&&s>=this.noteFilter.controlPointCount))))}clearInvalidEnvelopeTargets(){for(let t=0;t<this.envelopeCount;t++){const s=this.envelopes[t].target,n=this.envelopes[t].index;this.supportsEnvelopeTarget(s,n)||(this.envelopes[t].target=e.instrumentAutomationTargets.dictionary.none.index,this.envelopes[t].index=0)}}getTransition(){return l(this.effects)?e.transitions[this.transition]:e.transitions.dictionary.normal}getFadeInSeconds(){return 4==this.type?0:et.fadeInSettingToSeconds(this.fadeIn)}getFadeOutTicks(){return 4==this.type?e.drumsetFadeOutTicks:et.fadeOutSettingToTicks(this.fadeOut)}getChord(){return u(this.effects)?e.chords[this.chord]:e.chords.dictionary.simultaneous}getDrumsetEnvelope(t){if(4!=this.type)throw new Error("Can't getDrumsetEnvelope() for non-drumset.");return e.envelopes[this.drumsetEnvelopes[t]]}}class _{constructor(){this.octave=0,this.instruments=[],this.patterns=[],this.bars=[],this.muted=!1}}class ${constructor(t){this.channels=[],null!=t?this.fromBase64String(t):this.initToDefault(!0)}getChannelCount(){return this.pitchChannelCount+this.noiseChannelCount}getMaxInstrumentsPerChannel(){return Math.max(this.layeredInstruments?e.layeredInstrumentCountMax:e.instrumentCountMin,this.patternInstruments?e.patternInstrumentCountMax:e.instrumentCountMin)}getMaxInstrumentsPerPattern(t){return this.getMaxInstrumentsPerPatternForChannel(this.channels[t])}getMaxInstrumentsPerPatternForChannel(t){return this.layeredInstruments?Math.min(e.layeredInstrumentCountMax,t.instruments.length):1}getChannelIsNoise(t){return t>=this.pitchChannelCount}initToDefault(t=!0){if(this.scale=0,this.key=0,this.loopStart=0,this.loopLength=4,this.tempo=150,this.beatsPerBar=8,this.barCount=16,this.patternsPerChannel=8,this.rhythm=1,this.layeredInstruments=!1,this.patternInstruments=!1,t){this.pitchChannelCount=3,this.noiseChannelCount=1;for(let t=0;t<this.getChannelCount();t++){const s=t>=this.pitchChannelCount;this.channels.length<=t&&(this.channels[t]=new _);const n=this.channels[t];n.octave=s?0:4-t;for(let t=0;t<this.patternsPerChannel;t++)n.patterns.length<=t?n.patterns[t]=new V:n.patterns[t].reset();n.patterns.length=this.patternsPerChannel;for(let t=0;t<e.instrumentCountMin;t++)n.instruments.length<=t&&(n.instruments[t]=new J(s)),n.instruments[t].setTypeAndReset(s?2:0,s);n.instruments.length=e.instrumentCountMin;for(let t=0;t<this.barCount;t++)n.bars[t]=t<4?1:0;n.bars.length=this.barCount}this.channels.length=this.getChannelCount()}}toBase64String(){let t,s=[];if(s.push(R[$.g]),s.push(110,R[this.pitchChannelCount],R[this.noiseChannelCount]),s.push(115,R[this.scale]),s.push(107,R[this.key]),s.push(108,R[this.loopStart>>6],R[63&this.loopStart]),s.push(101,R[this.loopLength-1>>6],R[this.loopLength-1&63]),s.push(116,R[this.tempo>>6],R[63&this.tempo]),s.push(97,R[this.beatsPerBar-1]),s.push(103,R[this.barCount-1>>6],R[this.barCount-1&63]),s.push(106,R[this.patternsPerChannel-1>>6],R[this.patternsPerChannel-1&63]),s.push(114,R[this.rhythm]),s.push(105,R[this.layeredInstruments<<1|this.patternInstruments]),this.layeredInstruments||this.patternInstruments)for(let t=0;t<this.getChannelCount();t++)s.push(R[this.channels[t].instruments.length-e.instrumentCountMin]);s.push(111);for(let t=0;t<this.pitchChannelCount;t++)s.push(R[this.channels[t].octave]);for(let t=0;t<this.getChannelCount();t++)for(let n=0;n<this.channels[t].instruments.length;n++){const i=this.channels[t].instruments[n];s.push(84,R[i.type]),s.push(118,R[i.volume]),s.push(117,R[i.preset>>6],R[63&i.preset]),s.push(102,R[i.eqFilter.controlPointCount]);for(let t=0;t<i.eqFilter.controlPointCount;t++){const e=i.eqFilter.controlPoints[t];s.push(R[e.type],R[e.freq],R[e.gain])}if(s.push(113,R[i.effects>>6],R[63&i.effects]),m(i.effects)){s.push(R[i.noteFilter.controlPointCount]);for(let t=0;t<i.noteFilter.controlPointCount;t++){const e=i.noteFilter.controlPoints[t];s.push(R[e.type],R[e.freq],R[e.gain])}}if(l(i.effects)&&s.push(R[i.transition]),u(i.effects)&&s.push(R[i.chord]),c(i.effects)&&s.push(R[i.pitchShift]),f(i.effects)&&s.push(R[i.detune]),p(i.effects)&&s.push(R[i.vibrato]),d(i.effects)&&s.push(R[i.distortion]),M(i.effects)&&s.push(R[i.bitcrusherFreq],R[i.bitcrusherQuantization]),S(i.effects)&&s.push(R[i.pan]),b(i.effects)&&s.push(R[i.chorus]),y(i.effects)&&s.push(R[i.echoSustain],R[i.echoDelay]),v(i.effects)&&s.push(R[i.reverb]),4!=i.type&&s.push(100,R[i.fadeIn],R[i.fadeOut]),5==i.type||7==i.type){s.push(72);const t=new A;for(let s=0;s<e.harmonicsControlPoints;s++)t.write(e.harmonicsControlPointBits,i.harmonicsWave.harmonics[s]);t.encodeBase64(s)}if(0==i.type)s.push(119,R[i.chipWave]),s.push(104,R[i.unison]);else if(1==i.type){s.push(65,R[i.algorithm]),s.push(70,R[i.feedbackType]),s.push(66,R[i.feedbackAmplitude]),s.push(81);for(let t=0;t<e.operatorCount;t++)s.push(R[i.operators[t].frequency]);s.push(80);for(let t=0;t<e.operatorCount;t++)s.push(R[i.operators[t].amplitude])}else if(2==i.type)s.push(119,R[i.chipNoise]);else if(3==i.type){s.push(83);const t=new A;for(let s=0;s<e.spectrumControlPoints;s++)t.write(e.spectrumControlPointBits,i.spectrumWave.spectrum[s]);t.encodeBase64(s)}else if(4==i.type){s.push(122);for(let t=0;t<e.drumCount;t++)s.push(R[i.drumsetEnvelopes[t]]);s.push(83);const t=new A;for(let s=0;s<e.drumCount;s++)for(let n=0;n<e.spectrumControlPoints;n++)t.write(e.spectrumControlPointBits,i.drumsetSpectrumWaves[s].spectrum[n]);t.encodeBase64(s)}else if(5==i.type)s.push(104,R[i.unison]);else if(6==i.type)s.push(87,R[i.pulseWidth]);else if(8==i.type)s.push(120,R[i.supersawDynamism],R[i.supersawSpread],R[i.supersawShape]),s.push(87,R[i.pulseWidth]);else{if(7!=i.type)throw new Error("Unknown instrument type.");if(s.push(104,R[i.unison]),e.stringSustainRange>32)throw new Error("Not enough bits to represent sustain value and type in same base64 character.");s.push(73,R[i.stringSustain|i.stringSustainType<<5])}s.push(69,R[i.envelopeCount]);for(let t=0;t<i.envelopeCount;t++)s.push(R[i.envelopes[t].target]),e.instrumentAutomationTargets[i.envelopes[t].target].maxCount>1&&s.push(R[i.envelopes[t].index]),s.push(R[i.envelopes[t].envelope])}s.push(98),t=new A;let n=0;for(;1<<n<this.patternsPerChannel+1;)n++;for(let e=0;e<this.getChannelCount();e++)for(let s=0;s<this.barCount;s++)t.write(n,this.channels[e].bars[s]);t.encodeBase64(s),s.push(112),t=new A;const i=new A,h=$.getNeededBits(e.noteSizeMax);for(let s=0;s<this.getChannelCount();s++){const n=this.channels[s],r=this.getMaxInstrumentsPerPattern(s),a=$.getNeededBits(r-e.instrumentCountMin),o=$.getNeededBits(n.instruments.length-1),l=this.getChannelIsNoise(s),u=l?0:n.octave*e.pitchesPerOctave;let c=l?4:u;const f=l?[4,6,7,2,3,8,0,10]:[0,7,12,19,24,-5,-12],p=[];for(let t=0;t<f.length;t++)f[t]+=u;for(const s of n.patterns){if(this.patternInstruments){const n=w(e.instrumentCountMin,r,s.instruments.length);t.write(a,n-e.instrumentCountMin);for(let e=0;e<n;e++)t.write(o,s.instruments[e])}if(s.notes.length>0){t.write(1,1);let n=0;for(const r of s.notes){r.start>n&&(t.write(2,0),t.writePartDuration(r.start-n)),i.clear();for(let t=1;t<r.pitches.length;t++)i.write(1,1);r.pitches.length<e.maxChordSize&&i.write(1,0),i.writePinCount(r.pins.length-1),i.write(h,r.pins[0].size);let s=0,a=r.pitches[0],o=a;const l=[];for(let t=1;t<r.pins.length;t++){const e=r.pins[t],n=a+e.interval;o!=n?(i.write(1,1),l.push(n),o=n):i.write(1,0),i.writePartDuration(e.time-s),s=e.time,i.write(h,e.size)}const u=String.fromCharCode.apply(null,i.encodeBase64([])),m=p.indexOf(u);-1==m?(t.write(2,1),t.concat(i)):(t.write(1,1),t.writeLongTail(0,0,m),p.splice(m,1)),p.unshift(u),p.length>10&&p.pop();const d=r.pitches.concat(l);for(let e=0;e<d.length;e++){const s=d[e],n=f.indexOf(s);if(-1==n){let e=0,n=c;if(n<s)for(;n!=s;)n++,-1==f.indexOf(n)&&e++;else for(;n!=s;)n--,-1==f.indexOf(n)&&e--;t.write(1,0),t.writePitchInterval(e)}else t.write(1,1),t.write(3,n),f.splice(n,1);f.unshift(s),f.length>8&&f.pop(),c=e==r.pitches.length-1?r.pitches[0]:s}0==r.start&&t.write(1,r.continuesLastPattern?1:0),n=r.end}n<this.beatsPerBar*e.partsPerBeat&&(t.write(2,0),t.writePartDuration(this.beatsPerBar*e.partsPerBeat-n))}else t.write(1,0)}}let r=t.lengthBase64(),a=[];for(;r>0;)a.unshift(R[63&r]),r>>=6;s.push(R[a.length]),Array.prototype.push.apply(s,a),t.encodeBase64(s);const o=64e3;if(s.length<o)return String.fromCharCode.apply(null,s);{let t="";for(let e=0;e<s.length;e+=o)t+=String.fromCharCode.apply(null,s.slice(e,e+o));return t}}static I(t){return 0==t?t=1:1==t&&(t=0),e.envelopes[L(0,e.envelopes.length,t)]}fromBase64String(t){if(null==t||""==t)return void this.initToDefault(!0);let s=0;for(;t.charCodeAt(s)<=32;)s++;if(35==t.charCodeAt(s)&&s++,123==t.charCodeAt(s))return void this.fromJsonObject(JSON.parse(0==s?t:t.substring(s)));const n=B[t.charCodeAt(s++)];if(-1==n||n>$.g||n<$.P)return;const i=n<3,h=n<4,r=n<5,a=n<6,o=n<7,g=n<8,I=n<9;if(this.initToDefault(I),i){for(const t of this.channels)t.instruments[0].transition=e.transitions.dictionary.interrupt.index,t.instruments[0].effects|=1024;this.channels[3].instruments[0].chipNoise=0}let P=null;if(I){P=[];for(let t=P.length;t<this.getChannelCount();t++){P[t]=[];for(let s=0;s<e.instrumentCountMin;s++)P[t][s]={}}}let D,F=0,T=0,k=-1;for(;s<t.length;)switch(D=t.charCodeAt(s++)){case 110:this.pitchChannelCount=B[t.charCodeAt(s++)],this.noiseChannelCount=B[t.charCodeAt(s++)],this.pitchChannelCount=w(e.pitchChannelCountMin,e.pitchChannelCountMax,this.pitchChannelCount),this.noiseChannelCount=w(e.noiseChannelCountMin,e.noiseChannelCountMax,this.noiseChannelCount);for(let t=this.channels.length;t<this.getChannelCount();t++)this.channels[t]=new _;if(this.channels.length=this.getChannelCount(),I)for(let t=P.length;t<this.getChannelCount();t++){P[t]=[];for(let s=0;s<e.instrumentCountMin;s++)P[t][s]={}}break;case 115:this.scale=B[t.charCodeAt(s++)],i&&10==this.scale&&(this.scale=11);break;case 107:this.key=L(0,e.keys.length,o?11-B[t.charCodeAt(s++)]:B[t.charCodeAt(s++)]);break;case 108:this.loopStart=r?B[t.charCodeAt(s++)]:(B[t.charCodeAt(s++)]<<6)+B[t.charCodeAt(s++)];break;case 101:this.loopLength=r?B[t.charCodeAt(s++)]:(B[t.charCodeAt(s++)]<<6)+B[t.charCodeAt(s++)]+1;break;case 116:this.tempo=h?[95,120,151,190][B[t.charCodeAt(s++)]]:o?[88,95,103,111,120,130,140,151,163,176,190,206,222,240,259][B[t.charCodeAt(s++)]]:B[t.charCodeAt(s++)]<<6|B[t.charCodeAt(s++)],this.tempo=L(e.tempoMin,e.tempoMax+1,this.tempo);break;case 109:I&&(F=B[t.charCodeAt(s++)],F=L(0,4,F));break;case 97:this.beatsPerBar=i?[6,7,8,9,10][B[t.charCodeAt(s++)]]:B[t.charCodeAt(s++)]+1,this.beatsPerBar=Math.max(e.beatsPerBarMin,Math.min(e.beatsPerBarMax,this.beatsPerBar));break;case 103:{const n=(B[t.charCodeAt(s++)]<<6)+B[t.charCodeAt(s++)]+1;this.barCount=w(e.barCountMin,e.barCountMax,n);for(let t=0;t<this.getChannelCount();t++){for(let e=this.channels[t].bars.length;e<this.barCount;e++)this.channels[t].bars[e]=1;this.channels[t].bars.length=this.barCount}}break;case 106:{let n;n=g?B[t.charCodeAt(s++)]+1:(B[t.charCodeAt(s++)]<<6)+B[t.charCodeAt(s++)]+1,this.patternsPerChannel=w(1,e.barCountMax,n);const i=this.getChannelCount();for(let t=0;t<i;t++){const e=this.channels[t].patterns;for(let t=e.length;t<this.patternsPerChannel;t++)e[t]=new V;e.length=this.patternsPerChannel}}break;case 105:if(I){const n=w(e.instrumentCountMin,e.patternInstrumentCountMax,B[t.charCodeAt(s++)]+e.instrumentCountMin);this.layeredInstruments=!1,this.patternInstruments=n>1;for(let t=0;t<this.getChannelCount();t++){const e=t>=this.pitchChannelCount;for(let s=this.channels[t].instruments.length;s<n;s++)this.channels[t].instruments[s]=new J(e);if(this.channels[t].instruments.length=n,a)for(let s=0;s<n;s++)this.channels[t].instruments[s].setTypeAndReset(e?2:0,e);for(let e=P[t].length;e<n;e++)P[t][e]={}}}else{const n=B[t.charCodeAt(s++)];this.layeredInstruments=0!=(2&n),this.patternInstruments=0!=(1&n);for(let n=0;n<this.getChannelCount();n++){let i=1;(this.layeredInstruments||this.patternInstruments)&&(i=w(e.instrumentCountMin,this.getMaxInstrumentsPerChannel(),B[t.charCodeAt(s++)]+e.instrumentCountMin));const h=this.channels[n],r=this.getChannelIsNoise(n);for(let t=h.instruments.length;t<i;t++)h.instruments[t]=new J(r);h.instruments.length=i}}break;case 114:this.rhythm=B[t.charCodeAt(s++)];break;case 111:if(i){const n=B[t.charCodeAt(s++)];this.channels[n].octave=L(0,e.pitchOctaves,B[t.charCodeAt(s++)]+1),n>=this.pitchChannelCount&&(this.channels[n].octave=0)}else if(I)for(let n=0;n<this.getChannelCount();n++)this.channels[n].octave=L(0,e.pitchOctaves,B[t.charCodeAt(s++)]+1),n>=this.pitchChannelCount&&(this.channels[n].octave=0);else{for(let n=0;n<this.pitchChannelCount;n++)this.channels[n].octave=L(0,e.pitchOctaves,B[t.charCodeAt(s++)]);for(let t=this.pitchChannelCount;t<this.getChannelCount();t++)this.channels[t].octave=0}break;case 84:{k++,k>=this.channels[T].instruments.length&&(T++,k=0),w(0,this.channels.length-1,T);const n=this.channels[T].instruments[k],i=w(0,8,B[t.charCodeAt(s++)]);n.setTypeAndReset(i,T>=this.pitchChannelCount),o&&(n.effects=0,F>0&&!this.getChannelIsNoise(T)&&(n.reverb=F,n.effects|=1),n.chord!=e.chords.dictionary.simultaneous.index&&(n.effects|=2048))}break;case 117:{const e=B[t.charCodeAt(s++)]<<6|B[t.charCodeAt(s++)];this.channels[T].instruments[k].preset=e}break;case 119:if(i){const n=[1,2,3,4,5,6,7,8,0],i=B[t.charCodeAt(s++)],h=this.channels[i].instruments[0];h.chipWave=L(0,e.chipWaves.length,0|n[B[t.charCodeAt(s++)]]),h.convertLegacySettings(P[i][0])}else if(a){const n=[1,2,3,4,5,6,7,8,0];for(let i=0;i<this.getChannelCount();i++)for(const h of this.channels[i].instruments)i>=this.pitchChannelCount?h.chipNoise=L(0,e.chipNoises.length,B[t.charCodeAt(s++)]):h.chipWave=L(0,e.chipWaves.length,0|n[B[t.charCodeAt(s++)]])}else if(o){const n=[1,2,3,4,5,6,7,8,0];T>=this.pitchChannelCount?this.channels[T].instruments[k].chipNoise=L(0,e.chipNoises.length,B[t.charCodeAt(s++)]):this.channels[T].instruments[k].chipWave=L(0,e.chipWaves.length,0|n[B[t.charCodeAt(s++)]])}else T>=this.pitchChannelCount?this.channels[T].instruments[k].chipNoise=L(0,e.chipNoises.length,B[t.charCodeAt(s++)]):this.channels[T].instruments[k].chipWave=L(0,e.chipWaves.length,B[t.charCodeAt(s++)]);break;case 102:if(I)if(o){const n=[10,6,3,0,8,5,2],h=["none","none","none","none","decay 1","decay 2","decay 3"];if(i){const i=B[t.charCodeAt(s++)],r=this.channels[i].instruments[0],a=P[i][0],o=[1,3,4,5][L(0,n.length,B[t.charCodeAt(s++)])];a.filterCutoff=n[o],a.filterResonance=0,a.filterEnvelope=e.envelopes.dictionary[h[o]],r.convertLegacySettings(a)}else if(a)for(let i=0;i<this.getChannelCount();i++)for(let r=0;r<this.channels[i].instruments.length;r++){const a=this.channels[i].instruments[r],o=P[i][r],l=L(0,n.length,B[t.charCodeAt(s++)]+1);i<this.pitchChannelCount?(o.filterCutoff=n[l],o.filterResonance=0,o.filterEnvelope=e.envelopes.dictionary[h[l]]):(o.filterCutoff=10,o.filterResonance=0,o.filterEnvelope=e.envelopes.dictionary.none),a.convertLegacySettings(o)}else{const i=L(0,n.length,B[t.charCodeAt(s++)]),r=this.channels[T].instruments[k],a=P[T][k];a.filterCutoff=n[i],a.filterResonance=0,a.filterEnvelope=e.envelopes.dictionary[h[i]],r.convertLegacySettings(a)}}else{const e=11,n=this.channels[T].instruments[k],i=P[T][k];i.filterCutoff=L(0,e,B[t.charCodeAt(s++)]),n.convertLegacySettings(i)}else{const n=this.channels[T].instruments[k],i=B[t.charCodeAt(s++)];n.eqFilter.controlPointCount=L(0,e.filterMaxPoints+1,i);for(let t=n.eqFilter.controlPoints.length;t<n.eqFilter.controlPointCount;t++)n.eqFilter.controlPoints[t]=new U;for(let i=0;i<n.eqFilter.controlPointCount;i++){const h=n.eqFilter.controlPoints[i];h.type=L(0,3,B[t.charCodeAt(s++)]),h.freq=L(0,e.filterFreqRange,B[t.charCodeAt(s++)]),h.gain=L(0,e.filterGainRange,B[t.charCodeAt(s++)])}for(let t=n.eqFilter.controlPointCount;t<i;t++)s+=3}break;case 121:if(I){const e=8,n=this.channels[T].instruments[k],i=P[T][k];i.filterResonance=L(0,e,B[t.charCodeAt(s++)]),n.convertLegacySettings(i)}break;case 122:{const n=this.channels[T].instruments[k];if(I)if(4==n.type)for(let i=0;i<e.drumCount;i++)n.drumsetEnvelopes[i]=$.I(B[t.charCodeAt(s++)]).index;else{const e=P[T][k];e.filterEnvelope=$.I(B[t.charCodeAt(s++)]),n.convertLegacySettings(e)}else for(let i=0;i<e.drumCount;i++)n.drumsetEnvelopes[i]=L(0,e.envelopes.length,B[t.charCodeAt(s++)])}break;case 87:{const n=this.channels[T].instruments[k];if(n.pulseWidth=L(0,e.pulseWidthRange,B[t.charCodeAt(s++)]),I){const e=P[T][k];e.pulseEnvelope=$.I(B[t.charCodeAt(s++)]),n.convertLegacySettings(e)}}break;case 120:{const n=this.channels[T].instruments[k];n.supersawDynamism=L(0,e.supersawDynamismMax+1,B[t.charCodeAt(s++)]),n.supersawSpread=L(0,e.supersawSpreadMax+1,B[t.charCodeAt(s++)]),n.supersawShape=L(0,e.supersawShapeMax+1,B[t.charCodeAt(s++)])}break;case 73:{const n=this.channels[T].instruments[k],i=B[t.charCodeAt(s++)];n.stringSustain=L(0,e.stringSustainRange,31&i),n.stringSustainType=e.enableAcousticSustain?L(0,2,i>>5):0}break;case 100:if(I){const n=[{transition:"interrupt",fadeInSeconds:0,fadeOutTicks:-1},{transition:"normal",fadeInSeconds:0,fadeOutTicks:-3},{transition:"normal",fadeInSeconds:.025,fadeOutTicks:-3},{transition:"slide in pattern",fadeInSeconds:.025,fadeOutTicks:-3},{transition:"normal",fadeInSeconds:.04,fadeOutTicks:6},{transition:"normal",fadeInSeconds:0,fadeOutTicks:48},{transition:"normal",fadeInSeconds:.0125,fadeOutTicks:72},{transition:"normal",fadeInSeconds:.06,fadeOutTicks:96}];if(i){const i=B[t.charCodeAt(s++)],h=n[L(0,n.length,B[t.charCodeAt(s++)])],r=this.channels[i].instruments[0];r.fadeIn=et.secondsToFadeInSetting(h.fadeInSeconds),r.fadeOut=et.ticksToFadeOutSetting(h.fadeOutTicks),r.transition=e.transitions.dictionary[h.transition].index,r.transition!=e.transitions.dictionary.normal.index&&(r.effects|=1024)}else if(a)for(let i=0;i<this.getChannelCount();i++)for(const h of this.channels[i].instruments){const i=n[L(0,n.length,B[t.charCodeAt(s++)])];h.fadeIn=et.secondsToFadeInSetting(i.fadeInSeconds),h.fadeOut=et.ticksToFadeOutSetting(i.fadeOutTicks),h.transition=e.transitions.dictionary[i.transition].index,h.transition!=e.transitions.dictionary.normal.index&&(h.effects|=1024)}else{const i=n[L(0,n.length,B[t.charCodeAt(s++)])],h=this.channels[T].instruments[k];h.fadeIn=et.secondsToFadeInSetting(i.fadeInSeconds),h.fadeOut=et.ticksToFadeOutSetting(i.fadeOutTicks),h.transition=e.transitions.dictionary[i.transition].index,h.transition!=e.transitions.dictionary.normal.index&&(h.effects|=1024)}}else{const n=this.channels[T].instruments[k];n.fadeIn=L(0,e.fadeInRange,B[t.charCodeAt(s++)]),n.fadeOut=L(0,e.fadeOutTicks.length,B[t.charCodeAt(s++)])}break;case 99:if(I)if(o)if(i){const n=[0,3,2,0],i=["none","none","none","tremolo2"],h=B[t.charCodeAt(s++)],r=L(0,n.length,B[t.charCodeAt(s++)]),a=this.channels[h].instruments[0],o=P[h][0];a.vibrato=n[r],null!=o.filterEnvelope&&1!=o.filterEnvelope.type||(o.filterEnvelope=e.envelopes.dictionary[i[r]],a.convertLegacySettings(o)),a.vibrato!=e.vibratos.dictionary.none.index&&(a.effects|=512)}else if(a){const n=[0,1,2,3,0,0],i=["none","none","none","none","tremolo5","tremolo2"];for(let h=0;h<this.getChannelCount();h++)for(let r=0;r<this.channels[h].instruments.length;r++){const a=L(0,n.length,B[t.charCodeAt(s++)]),o=this.channels[h].instruments[r],l=P[h][r];o.vibrato=n[a],null!=l.filterEnvelope&&1!=l.filterEnvelope.type||(l.filterEnvelope=e.envelopes.dictionary[i[a]],o.convertLegacySettings(l)),o.vibrato!=e.vibratos.dictionary.none.index&&(o.effects|=512),0==F||this.getChannelIsNoise(h)||(o.effects|=1,o.reverb=F)}}else{const n=[0,1,2,3,0,0],i=["none","none","none","none","tremolo5","tremolo2"],h=L(0,n.length,B[t.charCodeAt(s++)]),r=this.channels[T].instruments[k],a=P[T][k];r.vibrato=n[h],null!=a.filterEnvelope&&1!=a.filterEnvelope.type||(a.filterEnvelope=e.envelopes.dictionary[i[h]],r.convertLegacySettings(a)),r.vibrato!=e.vibratos.dictionary.none.index&&(r.effects|=512),0!=F&&(r.effects|=1,r.reverb=F)}else{const n=this.channels[T].instruments[k],i=L(0,e.vibratos.length,B[t.charCodeAt(s++)]);n.vibrato=i,n.vibrato!=e.vibratos.dictionary.none.index&&(n.effects|=512)}break;case 104:if(i){const n=B[t.charCodeAt(s++)];this.channels[n].instruments[0].unison=L(0,e.unisons.length,B[t.charCodeAt(s++)])}else if(a)for(let n=0;n<this.getChannelCount();n++)for(const i of this.channels[n].instruments){const n=B[t.charCodeAt(s++)];let h=L(0,e.unisons.length,n);8==n&&(h=2,i.chord=3),i.unison=h}else if(o){const n=B[t.charCodeAt(s++)];let i=L(0,e.unisons.length,n);8==n&&(i=2,this.channels[T].instruments[k].chord=3),this.channels[T].instruments[k].unison=i}else this.channels[T].instruments[k].unison=L(0,e.unisons.length,B[t.charCodeAt(s++)]);break;case 67:if(I){const n=this.channels[T].instruments[k];n.chord=L(0,e.chords.length,B[t.charCodeAt(s++)]),n.chord!=e.chords.dictionary.simultaneous.index&&(n.effects|=2048)}break;case 113:{const n=this.channels[T].instruments[k];if(I){n.effects=4095&B[t.charCodeAt(s++)],0==F?n.effects&=-2:v(n.effects)&&(n.reverb=F),n.pan!=e.panCenter&&(n.effects|=4),n.vibrato!=e.vibratos.dictionary.none.index&&(n.effects|=4);const i=P[T][k];n.convertLegacySettings(i)}else{if(n.effects=B[t.charCodeAt(s++)]<<6|B[t.charCodeAt(s++)],m(n.effects)){const i=B[t.charCodeAt(s++)];n.noteFilter.controlPointCount=L(0,e.filterMaxPoints+1,i);for(let t=n.noteFilter.controlPoints.length;t<n.noteFilter.controlPointCount;t++)n.noteFilter.controlPoints[t]=new U;for(let i=0;i<n.noteFilter.controlPointCount;i++){const h=n.noteFilter.controlPoints[i];h.type=L(0,3,B[t.charCodeAt(s++)]),h.freq=L(0,e.filterFreqRange,B[t.charCodeAt(s++)]),h.gain=L(0,e.filterGainRange,B[t.charCodeAt(s++)])}for(let t=n.noteFilter.controlPointCount;t<i;t++)s+=3}l(n.effects)&&(n.transition=L(0,e.transitions.length,B[t.charCodeAt(s++)])),u(n.effects)&&(n.chord=L(0,e.chords.length,B[t.charCodeAt(s++)])),c(n.effects)&&(n.pitchShift=L(0,e.pitchShiftRange,B[t.charCodeAt(s++)])),f(n.effects)&&(n.detune=L(0,e.detuneMax+1,B[t.charCodeAt(s++)])),p(n.effects)&&(n.vibrato=L(0,e.vibratos.length,B[t.charCodeAt(s++)])),d(n.effects)&&(n.distortion=L(0,e.distortionRange,B[t.charCodeAt(s++)])),M(n.effects)&&(n.bitcrusherFreq=L(0,e.bitcrusherFreqRange,B[t.charCodeAt(s++)]),n.bitcrusherQuantization=L(0,e.bitcrusherQuantizationRange,B[t.charCodeAt(s++)])),S(n.effects)&&(n.pan=L(0,e.panMax+1,B[t.charCodeAt(s++)])),b(n.effects)&&(n.chorus=L(0,e.chorusRange,B[t.charCodeAt(s++)])),y(n.effects)&&(n.echoSustain=L(0,e.echoSustainRange,B[t.charCodeAt(s++)]),n.echoDelay=L(0,e.echoDelayRange,B[t.charCodeAt(s++)])),v(n.effects)&&(n.reverb=L(0,e.reverbRange,B[t.charCodeAt(s++)]))}n.effects&=4095}break;case 118:if(i){const n=B[t.charCodeAt(s++)],i=this.channels[n].instruments[0];i.volume=L(0,e.volumeRange,B[t.charCodeAt(s++)]),5==i.volume&&(i.volume=e.volumeRange-1)}else if(a)for(let n=0;n<this.getChannelCount();n++)for(const i of this.channels[n].instruments)i.volume=L(0,e.volumeRange,B[t.charCodeAt(s++)]),5==i.volume&&(i.volume=e.volumeRange-1);else if(o){const n=this.channels[T].instruments[k];n.volume=L(0,e.volumeRange,B[t.charCodeAt(s++)]),5==n.volume&&(n.volume=e.volumeRange-1)}else{this.channels[T].instruments[k].volume=L(0,e.volumeRange,B[t.charCodeAt(s++)])}break;case 76:if(I){this.channels[T].instruments[k].pan=L(0,e.panMax+1,B[t.charCodeAt(s++)])}break;case 65:{const n=this.channels[T].instruments[k];if(n.algorithm=L(0,e.algorithms.length,B[t.charCodeAt(s++)]),I){const t=P[T][k];n.convertLegacySettings(t)}}break;case 70:this.channels[T].instruments[k].feedbackType=L(0,e.feedbacks.length,B[t.charCodeAt(s++)]);break;case 66:this.channels[T].instruments[k].feedbackAmplitude=L(0,e.operatorAmplitudeMax+1,B[t.charCodeAt(s++)]);break;case 86:if(I){const e=this.channels[T].instruments[k],n=P[T][k];n.feedbackEnvelope=$.I(B[t.charCodeAt(s++)]),e.convertLegacySettings(n)}break;case 81:for(let n=0;n<e.operatorCount;n++)this.channels[T].instruments[k].operators[n].frequency=L(0,e.operatorFrequencies.length,B[t.charCodeAt(s++)]);break;case 80:for(let n=0;n<e.operatorCount;n++)this.channels[T].instruments[k].operators[n].amplitude=L(0,e.operatorAmplitudeMax+1,B[t.charCodeAt(s++)]);break;case 69:{const n=this.channels[T].instruments[k];if(I){const i=P[T][k];i.operatorEnvelopes=[];for(let n=0;n<e.operatorCount;n++)i.operatorEnvelopes[n]=$.I(B[t.charCodeAt(s++)]);n.convertLegacySettings(i)}else{const i=L(0,e.maxEnvelopeCount+1,B[t.charCodeAt(s++)]);for(let h=0;h<i;h++){const i=L(0,e.instrumentAutomationTargets.length,B[t.charCodeAt(s++)]);let h=0;const r=e.instrumentAutomationTargets[i].maxCount;r>1&&(h=L(0,r,B[t.charCodeAt(s++)]));const a=L(0,e.envelopes.length,B[t.charCodeAt(s++)]);n.addEnvelope(i,h,a)}}}break;case 83:{const n=this.channels[T].instruments[k];if(3==n.type){const i=Math.ceil(e.spectrumControlPoints*e.spectrumControlPointBits/6),h=new C(t,s,s+i);for(let t=0;t<e.spectrumControlPoints;t++)n.spectrumWave.spectrum[t]=h.read(e.spectrumControlPointBits);n.spectrumWave.markCustomWaveDirty(),s+=i}else{if(4!=n.type)throw new Error("Unhandled instrument type for spectrum song tag code.");{const i=Math.ceil(e.drumCount*e.spectrumControlPoints*e.spectrumControlPointBits/6),h=new C(t,s,s+i);for(let t=0;t<e.drumCount;t++){for(let s=0;s<e.spectrumControlPoints;s++)n.drumsetSpectrumWaves[t].spectrum[s]=h.read(e.spectrumControlPointBits);n.drumsetSpectrumWaves[t].markCustomWaveDirty()}s+=i}}}break;case 72:{const n=this.channels[T].instruments[k],i=Math.ceil(e.harmonicsControlPoints*e.harmonicsControlPointBits/6),h=new C(t,s,s+i);for(let t=0;t<e.harmonicsControlPoints;t++)n.harmonicsWave.harmonics[t]=h.read(e.harmonicsControlPointBits);n.harmonicsWave.markCustomWaveDirty(),s+=i}break;case 98:{let e;if(i){const n=B[t.charCodeAt(s++)],i=B[t.charCodeAt(s++)];e=Math.ceil(.5*i);const h=new C(t,s,s+e);for(let t=0;t<i;t++)this.channels[n].bars[t]=h.read(3)+1}else if(r){let n=0;for(;1<<n<this.patternsPerChannel;)n++;e=Math.ceil(this.getChannelCount()*this.barCount*n/6);const i=new C(t,s,s+e);for(let t=0;t<this.getChannelCount();t++)for(let e=0;e<this.barCount;e++)this.channels[t].bars[e]=i.read(n)+1}else{let n=0;for(;1<<n<this.patternsPerChannel+1;)n++;e=Math.ceil(this.getChannelCount()*this.barCount*n/6);const i=new C(t,s,s+e);for(let t=0;t<this.getChannelCount();t++)for(let e=0;e<this.barCount;e++)this.channels[t].bars[e]=i.read(n)}s+=e}break;case 112:{let n,h=0;if(i)n=B[t.charCodeAt(s++)],s++,h=B[t.charCodeAt(s++)],h<<=6,h+=B[t.charCodeAt(s++)];else{n=0;let e=w(1,4,B[t.charCodeAt(s++)]);for(;e>0;)h<<=6,h+=B[t.charCodeAt(s++)],e--}const r=new C(t,s,s+h);s+=h;const a=$.getNeededBits(e.noteSizeMax);for(;;){const t=this.channels[n],s=this.getChannelIsNoise(n),h=this.getMaxInstrumentsPerPattern(n),l=$.getNeededBits(h-e.instrumentCountMin),u=$.getNeededBits(t.instruments.length-1),c=s?0:12*t.octave;let f=s?4:c;const p=s?[4,6,7,2,3,8,0,10]:[0,7,12,19,24,-5,-12],m=[];for(let t=0;t<p.length;t++)p[t]+=c;for(let s=0;s<this.patternsPerChannel;s++){const n=t.patterns[s];if(I)n.instruments[0]=w(0,t.instruments.length-1,r.read(u)),n.instruments.length=1;else if(this.patternInstruments){const s=w(e.instrumentCountMin,h,r.read(l)+e.instrumentCountMin);for(let e=0;e<s;e++)n.instruments[e]=w(0,t.instruments.length-1,r.read(u));n.instruments.length=s}else n.instruments[0]=0,n.instruments.length=e.instrumentCountMin;if(!i&&0==r.read(1)){n.notes.length=0;continue}let c=0;const d=n.notes;let M=0;for(;c<this.beatsPerBar*e.partsPerBeat;){const t=1==r.read(1);let s=!1,n=0;if(t?n=w(0,m.length-1,r.readLongTail(0,0)):s=1==r.read(1),t||s){let s,i,h;if(t)s=m[n],m.splice(n,1);else{for(s={},s.pitchCount=1;s.pitchCount<e.maxChordSize&&1==r.read(1);)s.pitchCount++;s.pinCount=r.readPinCount(),s.initialSize=r.read(a),s.pins=[],s.length=0,s.bendCount=0;for(let t=0;t<s.pinCount;t++){let t={};t.pitchBend=1==r.read(1),t.pitchBend&&s.bendCount++,s.length+=o?r.readLegacyPartDuration()*e.partsPerBeat/e.rhythms[this.rhythm].stepsPerBeat:r.readPartDuration(),t.time=s.length,t.size=r.read(a),s.pins.push(t)}}m.unshift(s),m.length>10&&m.pop(),d.length<=M?(i=new E(0,c,c+s.length,s.initialSize),d[M++]=i):(i=d[M++],i.start=c,i.end=c+s.length,i.pins[0].size=s.initialSize);let l=0;const u=[];for(let t=0;t<s.pitchCount+s.bendCount;t++){if(1==r.read(1)){const t=w(0,p.length-1,r.read(3));h=p[t],p.splice(t,1)}else{const t=r.readPitchInterval();h=f;let e=t;for(;e>0;){for(h++;-1!=p.indexOf(h);)h++;e--}for(;e<0;){for(h--;-1!=p.indexOf(h);)h--;e++}}p.unshift(h),p.length>8&&p.pop(),t<s.pitchCount?i.pitches[l++]=h:u.push(h),f=t==s.pitchCount-1?i.pitches[0]:h}i.pitches.length=l,u.unshift(i.pitches[0]);let S=1;for(const t of s.pins){t.pitchBend&&u.shift();const e=u[0]-i.pitches[0];if(i.pins.length<=S)i.pins[S++]=N(e,t.time,t.size);else{const s=i.pins[S++];s.interval=e,s.time=t.time,s.size=t.size}}i.pins.length=S,0!=i.start||I?i.continuesLastPattern=!1:i.continuesLastPattern=1==r.read(1),c=w(0,this.beatsPerBar*e.partsPerBeat,i.end)}else{c+=o?r.readLegacyPartDuration()*e.partsPerBeat/e.rhythms[this.rhythm].stepsPerBeat:r.readPartDuration()}}d.length=M}if(i)break;if(n++,n>=this.getChannelCount())break}}break;default:throw new Error("Unrecognized song tag code "+String.fromCharCode(D)+" at index "+(s-1))}}toJsonObject(t=!0,s=1,n=!0){const i=[];for(let e=0;e<this.getChannelCount();e++){const h=this.channels[e],r=[],a=this.getChannelIsNoise(e);for(const t of h.instruments)r.push(t.toJsonObject());const o=[];for(const t of h.patterns)o.push(t.toJsonObject(this));const l=[];if(t)for(let t=0;t<this.loopStart;t++)l.push(h.bars[t]);for(let t=0;t<s;t++)for(let t=this.loopStart;t<this.loopStart+this.loopLength;t++)l.push(h.bars[t]);if(n)for(let t=this.loopStart+this.loopLength;t<this.barCount;t++)l.push(h.bars[t]);const u={type:a?"drum":"pitch",instruments:r,patterns:o,sequence:l};a||(u.octaveScrollBar=h.octave-1),i.push(u)}return{format:$.T,version:$.g,scale:e.scales[this.scale].name,key:e.keys[this.key].name,introBars:this.loopStart,loopBars:this.loopLength,beatsPerBar:this.beatsPerBar,ticksPerBeat:e.rhythms[this.rhythm].stepsPerBeat,beatsPerMinute:this.tempo,layeredInstruments:this.layeredInstruments,patternInstruments:this.patternInstruments,channels:i}}fromJsonObject(t){if(this.initToDefault(!0),!t)return;if(this.scale=11,null!=t.scale){const s={"romani :)":"double harmonic :)","romani :(":"double harmonic :(","dbl harmonic :)":"double harmonic :)","dbl harmonic :(":"double harmonic :(",enigma:"strange"},n=null!=s[t.scale]?s[t.scale]:t.scale,i=e.scales.findIndex((t=>t.name==n));-1!=i&&(this.scale=i)}if(null!=t.key)if("number"==typeof t.key)this.key=(t.key+1200>>>0)%e.keys.length;else if("string"==typeof t.key){const e=t.key,s=e.charAt(0).toUpperCase(),n=e.charAt(1).toLowerCase();let i={C:0,D:2,E:4,F:5,G:7,A:9,B:11}[s];const h={"#":1,"♯":1,b:-1,"♭":-1}[n];null!=i&&(null!=h&&(i+=h),i<0&&(i+=12),i%=12,this.key=i)}null!=t.beatsPerMinute&&(this.tempo=L(e.tempoMin,e.tempoMax+1,0|t.beatsPerMinute));let s=0;null!=t.reverb&&(s=L(0,4,0|t.reverb)),null!=t.beatsPerBar&&(this.beatsPerBar=Math.max(e.beatsPerBarMin,Math.min(e.beatsPerBarMax,0|t.beatsPerBar)));let n=4;null!=t.ticksPerBeat&&(n=0|t.ticksPerBeat||4,this.rhythm=e.rhythms.findIndex((t=>t.stepsPerBeat==n)),-1==this.rhythm&&(this.rhythm=1));let i=1,h=1,r=1;if(null!=t.channels)for(const e of t.channels)e.instruments&&(i=Math.max(i,0|e.instruments.length)),e.patterns&&(h=Math.max(h,0|e.patterns.length)),e.sequence&&(r=Math.max(r,0|e.sequence.length));null!=t.layeredInstruments?this.layeredInstruments=!!t.layeredInstruments:this.layeredInstruments=!1,null!=t.patternInstruments?this.patternInstruments=!!t.patternInstruments:this.patternInstruments=i>1,this.patternsPerChannel=Math.min(h,e.barCountMax),this.barCount=Math.min(r,e.barCountMax),null!=t.introBars&&(this.loopStart=L(0,this.barCount,0|t.introBars)),null!=t.loopBars&&(this.loopLength=L(1,this.barCount-this.loopStart+1,0|t.loopBars));const a=[],o=[];if(null!=t.channels)for(let i=0;i<t.channels.length;i++){let h=t.channels[i];const r=new _;let l=!1;if(l=null!=h.type?"drum"==h.type:i>=3,l?o.push(r):a.push(r),null!=h.octaveScrollBar&&(r.octave=L(0,e.pitchOctaves,1+(0|h.octaveScrollBar)),l&&(r.octave=0)),Array.isArray(h.instruments)){const t=h.instruments;for(let e=0;e<t.length&&!(e>=this.getMaxInstrumentsPerChannel());e++){const n=new J(l);r.instruments[e]=n,n.fromJsonObject(t[e],l,s)}}for(let t=0;t<this.patternsPerChannel;t++){const e=new V;let s;r.patterns[t]=e,h.patterns&&(s=h.patterns[t]),null!=s&&e.fromJsonObject(s,this,r,n,l)}r.patterns.length=this.patternsPerChannel;for(let t=0;t<this.barCount;t++)r.bars[t]=null!=h.sequence?Math.min(this.patternsPerChannel,h.sequence[t]>>>0):0;r.bars.length=this.barCount}a.length>e.pitchChannelCountMax&&(a.length=e.pitchChannelCountMax),o.length>e.noiseChannelCountMax&&(o.length=e.noiseChannelCountMax),this.pitchChannelCount=a.length,this.noiseChannelCount=o.length,this.channels.length=0,Array.prototype.push.apply(this.channels,a),Array.prototype.push.apply(this.channels,o)}getPattern(t,e){if(e<0||e>=this.barCount)return null;const s=this.channels[t].bars[e];return 0==s?null:this.channels[t].patterns[s-1]}getBeatsPerMinute(){return this.tempo}static getNeededBits(t){return 32-Math.clz32(Math.ceil(t+1)-1)}}$.T="BeepBox",$.P=2,$.g=9;class Z{constructor(){this.delayLine=null,this.allPassG=0,this.allPassGDelta=0,this.sustainFilterA1=0,this.sustainFilterA1Delta=0,this.sustainFilterA2=0,this.sustainFilterA2Delta=0,this.sustainFilterB0=0,this.sustainFilterB0Delta=0,this.sustainFilterB1=0,this.sustainFilterB1Delta=0,this.sustainFilterB2=0,this.sustainFilterB2Delta=0,this.reset()}reset(){this.delayIndex=-1,this.allPassSample=0,this.allPassPrevInput=0,this.sustainFilterSample=0,this.sustainFilterPrevOutput2=0,this.sustainFilterPrevInput1=0,this.sustainFilterPrevInput2=0,this.fractionalDelaySample=0,this.prevDelayLength=-1,this.delayResetOffset=0}update(t,s,n,i,h,r,a,o){const l=2*Math.PI*e.pickedStringDispersionCenterFreq/t.samplesPerSecond,u=this.prevDelayLength,c=n.phaseDeltas[i],f=n.phaseDeltaScales[i],p=c*Math.pow(f,h),m=2*Math.PI*c,d=2*Math.PI*p,M=2*m,S=2*d,b=Math.min(Math.PI,m*e.pickedStringDispersionFreqMult*Math.pow(l/m,e.pickedStringDispersionFreqScale)),y=Math.min(Math.PI,d*e.pickedStringDispersionFreqMult*Math.pow(l/d,e.pickedStringDispersionFreqScale)),v=2*Math.PI*e.pickedStringShelfHz/t.samplesPerSecond,g=(Math.pow(100,r)-1)/99,I=(Math.pow(100,a)-1)/99,P=1==o?.25:0,D=15.6,F=3*t.samplesPerSecond/48e3,T=Math.pow(.5,g*Math.pow(v/(m*D),1+2*P)*D),k=Math.pow(.5,I*Math.pow(v/(d*D),1+2*P)*D),O=Math.pow(T,.002),L=Math.pow(k,.002);et.tempFilterStartCoefficients.allPass1stOrderInvertPhaseAbove(b),t.tempFrequencyResponse.analyze(et.tempFilterStartCoefficients,M);const w=et.tempFilterStartCoefficients.b[0],R=-t.tempFrequencyResponse.angle()/M;et.tempFilterEndCoefficients.allPass1stOrderInvertPhaseAbove(y),t.tempFrequencyResponse.analyze(et.tempFilterEndCoefficients,S);const B=et.tempFilterEndCoefficients.b[0],C=-t.tempFrequencyResponse.angle()/S,A=0==o?0:1;if(0==A){const t=Math.pow(T,e.stringDecayRate),s=Math.pow(k,e.stringDecayRate);et.tempFilterStartCoefficients.highShelf2ndOrder(v,t,.5),et.tempFilterEndCoefficients.highShelf2ndOrder(v,s,.5)}else{const e=Math.pow(1==A?0:1,.25),s=Math.pow(F*F*m*3.3*48e3/t.samplesPerSecond,.5+P)/F/Math.pow(g,.5),n=Math.pow(F*F*d*3.3*48e3/t.samplesPerSecond,.5+P)/F/Math.pow(I,.5),i=s*Math.pow(2,.5-1.75*(1-Math.pow(1-e,.85))),h=n*Math.pow(2,.5-1.75*(1-Math.pow(1-e,.85))),r=Math.pow(2,-Math.pow(2,-Math.pow(e,.9))),a=Math.pow(2,-Math.pow(2,-Math.pow(e,.9)));et.tempFilterStartCoefficients.lowPass2ndOrderButterworth(x(i),r),et.tempFilterEndCoefficients.lowPass2ndOrderButterworth(x(h),a)}t.tempFrequencyResponse.analyze(et.tempFilterStartCoefficients,M);const N=et.tempFilterStartCoefficients.a[1],E=et.tempFilterStartCoefficients.a[2],V=et.tempFilterStartCoefficients.b[0]*O,z=et.tempFilterStartCoefficients.b[1]*O,W=et.tempFilterStartCoefficients.b[2]*O,G=-t.tempFrequencyResponse.angle()/M;t.tempFrequencyResponse.analyze(et.tempFilterEndCoefficients,S);const q=et.tempFilterEndCoefficients.a[1],j=et.tempFilterEndCoefficients.a[2],U=et.tempFilterEndCoefficients.b[0]*L,K=et.tempFilterEndCoefficients.b[1]*L,H=et.tempFilterEndCoefficients.b[2]*L,_=-t.tempFrequencyResponse.angle()/S,$=1/c,Z=1/p,Q=Math.ceil(2*Math.max($,Z)),X=$-R-G,Y=Z-C-_;this.prevDelayLength=X,this.delayLengthDelta=(Y-X)/h,this.allPassG=w,this.sustainFilterA1=N,this.sustainFilterA2=E,this.sustainFilterB0=V,this.sustainFilterB1=z,this.sustainFilterB2=W,this.allPassGDelta=(B-w)/h,this.sustainFilterA1Delta=(q-N)/h,this.sustainFilterA2Delta=(j-E)/h,this.sustainFilterB0Delta=(U-V)/h,this.sustainFilterB1Delta=(K-z)/h,this.sustainFilterB2Delta=(H-W)/h;const tt=Math.abs(Math.log2(X/u))>.01,st=-1==this.delayIndex||tt;if(null==this.delayLine||this.delayLine.length<=Q){const e=Math.ceil(2*t.samplesPerSecond/J.frequencyFromPitch(12)),s=new Float32Array(et.fittingPowerOfTwo(Math.max(e,Q)));if(!st&&null!=this.delayLine){const t=this.delayLine.length-1>>0,e=this.delayIndex+this.delayResetOffset;this.delayIndex=this.delayLine.length-this.delayResetOffset;for(let n=0;n<this.delayLine.length;n++)s[n]=this.delayLine[e+n&t]}this.delayLine=s}const nt=this.delayLine,it=nt.length-1>>0;if(st){this.delayIndex=0,this.allPassSample=0,this.allPassPrevInput=0,this.sustainFilterSample=0,this.sustainFilterPrevOutput2=0,this.sustainFilterPrevInput1=0,this.sustainFilterPrevInput2=0,this.fractionalDelaySample=0;const e=-X,n=Math.floor(e-$/2),i=Math.ceil(n+2*$);this.delayResetOffset=i;for(let t=n;t<=i;t++)nt[t&it]=0;const h=s.wave,r=h.length-1,a=r/$,o=Math.min(.2*$,.003*t.samplesPerSecond),l=Math.ceil(e),u=e+$+o,c=u;let f=(l-e)*a,p=0;for(let t=l;t<=c;t++){const s=0|f,n=s%r;let i=h[n];const l=f-s;i+=(h[n+1]-i)*l;const c=(i-p)/a,m=Math.min(1,(t-e)/o)*Math.min(1,(u-t)/o),d=m*m*(3-2*m);nt[t&it]+=c*d,p=i,f+=a}}}}class Q{constructor(){this.noteSecondsStart=0,this.noteSecondsEnd=0,this.noteTicksStart=0,this.noteTicksEnd=0,this.noteSizeStart=e.noteSizeMax,this.noteSizeEnd=e.noteSizeMax,this.prevNoteSize=e.noteSizeMax,this.nextNoteSize=e.noteSizeMax,this.k=e.noteSizeMax,this.prevNoteSecondsStart=0,this.prevNoteSecondsEnd=0,this.prevNoteTicksStart=0,this.prevNoteTicksEnd=0,this.O=e.noteSizeMax,this.prevSlideStart=!1,this.prevSlideEnd=!1,this.nextSlideStart=!1,this.nextSlideEnd=!1,this.prevSlideRatioStart=0,this.prevSlideRatioEnd=0,this.nextSlideRatioStart=0,this.nextSlideRatioEnd=0,this.envelopeStarts=[],this.envelopeEnds=[],this.L=[],this.R=0,this.lowpassCutoffDecayVolumeCompensation=1;for(let t=0;t<36;t++)this.envelopeStarts[t]=1,this.envelopeEnds[t]=1;this.reset()}reset(){this.noteSecondsEnd=0,this.noteTicksEnd=0,this.k=e.noteSizeMax,this.prevNoteSecondsEnd=0,this.prevNoteTicksEnd=0,this.O=e.noteSizeMax,this.R=0}computeEnvelopes(t,s,n,i,h){const r=t.getTransition();null==h||!h.atNoteStart||r.continues||h.forceContinueAtStart||(this.prevNoteSecondsEnd=this.noteSecondsEnd,this.prevNoteTicksEnd=this.noteTicksEnd,this.O=this.k,this.noteSecondsEnd=0,this.noteTicksEnd=0),null!=h&&(null!=h.note?this.k=h.note.pins[h.note.pins.length-1].size:this.k=e.noteSizeMax);const a=n+1,o=this.noteSecondsEnd,l=o+i,u=this.noteTicksEnd,c=u+1,f=this.prevNoteSecondsEnd,p=f+i,m=this.prevNoteTicksEnd,d=m+1,M=1/(e.ticksPerPart*e.partsPerBeat),S=M*n,b=M*a;let y=this.k,v=this.k,g=this.O,I=0,P=!1,D=!1,F=!1,T=!1,k=0,x=0,O=0,L=0;if(null!=h&&null!=h.note&&!h.passedEndOfNote){const t=h.note.getEndPinIndex(s),i=h.note.pins[t-1],o=h.note.pins[t],l=(h.note.start+i.time)*e.ticksPerPart,u=(h.note.start+o.time)*e.ticksPerPart,c=(n-l)/(u-l),f=(a-l)/(u-l);if(y=i.size+(o.size-i.size)*c,v=i.size+(o.size-i.size)*f,r.slides){const t=h.noteStartPart*e.ticksPerPart,s=h.noteEndPart*e.ticksPerPart,i=.5*(s-t),o=Math.min(i,r.slideTicks);null==h.prevNote||h.forceContinueAtStart||(n-t<o&&(P=!0,k=.5*(1-(n-t)/o)),a-t<o&&(D=!0,x=.5*(1-(a-t)/o))),null==h.nextNote||h.forceContinueAtEnd||(I=h.nextNote.pins[0].size,s-n<o&&(F=!0,O=.5*(1-(s-n)/o)),s-a<o&&(T=!0,L=.5*(1-(s-a)/o)))}}let w=1,R=!1;for(let s=0;s<=t.envelopeCount;s++){let n,i,h;if(s==t.envelopeCount){if(R)break;n=e.instrumentAutomationTargets.dictionary.noteVolume,i=0,h=e.envelopes.dictionary["note size"]}else{let r=t.envelopes[s];n=e.instrumentAutomationTargets[r.target],i=r.index,h=e.envelopes[r.envelope],0==h.type&&(R=!0)}if(null!=n.computeIndex){const e=n.computeIndex+i;let s=Q.computeEnvelope(h,o,S,y),r=Q.computeEnvelope(h,l,b,v);if(P){s+=(Q.computeEnvelope(h,f,S,g)-s)*k}if(D){r+=(Q.computeEnvelope(h,p,b,g)-r)*x}if(F){s+=(Q.computeEnvelope(h,0,S,I)-s)*O}if(T){r+=(Q.computeEnvelope(h,0,b,I)-r)*L}if(this.envelopeStarts[e]*=s,this.envelopeEnds[e]*=r,this.L[this.R++]=e,n.isFilter){const e=t.noteFilter;e.controlPointCount>i&&0==e.controlPoints[i].type&&(w=Math.max(w,Q.getLowpassCutoffDecayVolumeCompensation(h)))}}}this.noteSecondsStart=o,this.noteSecondsEnd=l,this.noteTicksStart=u,this.noteTicksEnd=c,this.prevNoteSecondsStart=f,this.prevNoteSecondsEnd=p,this.prevNoteTicksStart=m,this.prevNoteTicksEnd=d,this.prevNoteSize=g,this.nextNoteSize=I,this.noteSizeStart=y,this.noteSizeEnd=v,this.prevSlideStart=P,this.prevSlideEnd=D,this.nextSlideStart=F,this.nextSlideEnd=T,this.prevSlideRatioStart=k,this.prevSlideRatioEnd=x,this.nextSlideRatioStart=O,this.nextSlideRatioEnd=L,this.lowpassCutoffDecayVolumeCompensation=w}clearEnvelopes(){for(let t=0;t<this.R;t++){const e=this.L[t];this.envelopeStarts[e]=1,this.envelopeEnds[e]=1}this.R=0}static computeEnvelope(t,e,s,n){switch(t.type){case 0:return et.noteSizeToVolumeMult(n);case 1:return 1;case 4:return 1/(1+e*t.speed);case 5:return 1-1/(1+e*t.speed);case 6:return.5-.5*Math.cos(2*s*Math.PI*t.speed);case 7:return.75-.25*Math.cos(2*s*Math.PI*t.speed);case 2:return Math.max(1,2-10*e);case 3:const i=.25/Math.sqrt(t.speed);return e<i?e/i:1/(1+(e-i)*t.speed);case 8:return Math.pow(2,-t.speed*e);default:throw new Error("Unrecognized operator envelope type.")}}static getLowpassCutoffDecayVolumeCompensation(t){return 8==t.type?1.25+.025*t.speed:4==t.type?1+.02*t.speed:1}}class X{constructor(){this.pitches=Array(e.maxChordSize).fill(0),this.pitchCount=0,this.chordSize=0,this.drumsetPitch=null,this.note=null,this.prevNote=null,this.nextNote=null,this.prevNotePitchIndex=0,this.nextNotePitchIndex=0,this.freshlyAllocated=!0,this.atNoteStart=!1,this.isOnLastTick=!1,this.passedEndOfNote=!1,this.forceContinueAtStart=!1,this.forceContinueAtEnd=!1,this.noteStartPart=0,this.noteEndPart=0,this.ticksSinceReleased=0,this.liveInputSamplesHeld=0,this.lastInterval=0,this.noiseSample=0,this.phases=[],this.phaseDeltas=[],this.phaseDeltaScales=[],this.expression=0,this.expressionDelta=0,this.operatorExpressions=[],this.operatorExpressionDeltas=[],this.prevPitchExpressions=Array(e.maxPitchOrOperatorCount).fill(null),this.prevVibrato=null,this.prevStringDecay=null,this.pulseWidth=0,this.pulseWidthDelta=0,this.supersawDynamism=0,this.supersawDynamismDelta=0,this.supersawUnisonDetunes=[],this.supersawShape=0,this.supersawShapeDelta=0,this.supersawDelayLength=0,this.supersawDelayLengthDelta=0,this.supersawDelayLine=null,this.supersawDelayIndex=-1,this.supersawPrevPhaseDelta=null,this.pickedStrings=[],this.noteFilters=[],this.noteFilterCount=0,this.initialNoteFilterInput1=0,this.initialNoteFilterInput2=0,this.specialIntervalExpressionMult=1,this.feedbackOutputs=[],this.feedbackMult=0,this.feedbackDelta=0,this.envelopeComputer=new Q,this.reset()}reset(){this.noiseSample=0;for(let t=0;t<e.maxPitchOrOperatorCount;t++)this.phases[t]=0,this.feedbackOutputs[t]=0,this.prevPitchExpressions[t]=null;for(let t=0;t<this.noteFilterCount;t++)this.noteFilters[t].resetOutput();this.noteFilterCount=0,this.initialNoteFilterInput1=0,this.initialNoteFilterInput2=0,this.liveInputSamplesHeld=0,this.supersawDelayIndex=-1;for(const t of this.pickedStrings)t.reset();this.envelopeComputer.reset(),this.prevVibrato=null,this.prevStringDecay=null,this.supersawPrevPhaseDelta=null,this.drumsetPitch=null}}class Y{constructor(){this.awake=!1,this.computed=!1,this.tonesAddedInThisTick=!1,this.flushingDelayLines=!1,this.deactivateAfterThisTick=!1,this.attentuationProgress=0,this.flushedSamples=0,this.activeTones=new D,this.releasedTones=new D,this.liveInputTones=new D,this.type=0,this.synthesizer=null,this.wave=null,this.noisePitchFilterMult=1,this.unison=null,this.chord=null,this.effects=0,this.eqFilterVolume=1,this.eqFilterVolumeDelta=0,this.mixVolume=1,this.mixVolumeDelta=0,this.delayInputMult=0,this.delayInputMultDelta=0,this.distortion=0,this.distortionDelta=0,this.distortionDrive=0,this.distortionDriveDelta=0,this.distortionFractionalInput1=0,this.distortionFractionalInput2=0,this.distortionFractionalInput3=0,this.distortionPrevInput=0,this.distortionNextOutput=0,this.bitcrusherPrevInput=0,this.bitcrusherCurrentOutput=0,this.bitcrusherPhase=1,this.bitcrusherPhaseDelta=0,this.bitcrusherPhaseDeltaScale=1,this.bitcrusherScale=1,this.bitcrusherScaleScale=1,this.bitcrusherFoldLevel=1,this.bitcrusherFoldLevelScale=1,this.eqFilters=[],this.eqFilterCount=0,this.initialEqFilterInput1=0,this.initialEqFilterInput2=0,this.panningDelayLine=null,this.panningDelayPos=0,this.panningVolumeL=0,this.panningVolumeR=0,this.panningVolumeDeltaL=0,this.panningVolumeDeltaR=0,this.panningOffsetL=0,this.panningOffsetR=0,this.panningOffsetDeltaL=0,this.panningOffsetDeltaR=0,this.chorusDelayLineL=null,this.chorusDelayLineR=null,this.chorusDelayLineDirty=!1,this.chorusDelayPos=0,this.chorusPhase=0,this.chorusVoiceMult=0,this.chorusVoiceMultDelta=0,this.chorusCombinedMult=0,this.chorusCombinedMultDelta=0,this.echoDelayLineL=null,this.echoDelayLineR=null,this.echoDelayLineDirty=!1,this.echoDelayPos=0,this.echoDelayOffsetStart=0,this.echoDelayOffsetEnd=null,this.echoDelayOffsetRatio=0,this.echoDelayOffsetRatioDelta=0,this.echoMult=0,this.echoMultDelta=0,this.echoShelfA1=0,this.echoShelfB0=0,this.echoShelfB1=0,this.echoShelfSampleL=0,this.echoShelfSampleR=0,this.echoShelfPrevInputL=0,this.echoShelfPrevInputR=0,this.reverbDelayLine=null,this.reverbDelayLineDirty=!1,this.reverbDelayPos=0,this.reverbMult=0,this.reverbMultDelta=0,this.reverbShelfA1=0,this.reverbShelfB0=0,this.reverbShelfB1=0,this.reverbShelfSample0=0,this.reverbShelfSample1=0,this.reverbShelfSample2=0,this.reverbShelfSample3=0,this.reverbShelfPrevInput0=0,this.reverbShelfPrevInput1=0,this.reverbShelfPrevInput2=0,this.reverbShelfPrevInput3=0,this.spectrumWave=new G,this.harmonicsWave=new j,this.drumsetSpectrumWaves=[];for(let t=0;t<e.drumCount;t++)this.drumsetSpectrumWaves[t]=new G}allocateNecessaryBuffers(t,s,n){if(S(s.effects)&&(null==this.panningDelayLine||this.panningDelayLine.length<t.panningDelayBufferSize)&&(this.panningDelayLine=new Float32Array(t.panningDelayBufferSize)),b(s.effects)&&((null==this.chorusDelayLineL||this.chorusDelayLineL.length<t.chorusDelayBufferSize)&&(this.chorusDelayLineL=new Float32Array(t.chorusDelayBufferSize)),(null==this.chorusDelayLineR||this.chorusDelayLineR.length<t.chorusDelayBufferSize)&&(this.chorusDelayLineR=new Float32Array(t.chorusDelayBufferSize))),y(s.effects)){const t=Math.max(e.echoDelayRange>>1,s.echoDelay+1),i=2*et.fittingPowerOfTwo(t*e.echoDelayStepTicks*n);if(null==this.echoDelayLineL||null==this.echoDelayLineR)this.echoDelayLineL=new Float32Array(i),this.echoDelayLineR=new Float32Array(i);else if(this.echoDelayLineL.length<i||this.echoDelayLineR.length<i){const t=new Float32Array(i),e=new Float32Array(i),s=this.echoDelayLineL.length-1;for(let n=0;n<this.echoDelayLineL.length;n++)t[n]=this.echoDelayLineL[this.echoDelayPos+n&s],e[n]=this.echoDelayLineL[this.echoDelayPos+n&s];this.echoDelayPos=this.echoDelayLineL.length,this.echoDelayLineL=t,this.echoDelayLineR=e}}v(s.effects)&&null==this.reverbDelayLine&&(this.reverbDelayLine=new Float32Array(e.reverbDelayBufferSize))}deactivate(){this.bitcrusherPrevInput=0,this.bitcrusherCurrentOutput=0,this.bitcrusherPhase=1;for(let t=0;t<this.eqFilterCount;t++)this.eqFilters[t].resetOutput();if(this.eqFilterCount=0,this.initialEqFilterInput1=0,this.initialEqFilterInput2=0,this.distortionFractionalInput1=0,this.distortionFractionalInput2=0,this.distortionFractionalInput3=0,this.distortionPrevInput=0,this.distortionNextOutput=0,this.panningDelayPos=0,null!=this.panningDelayLine)for(let t=0;t<this.panningDelayLine.length;t++)this.panningDelayLine[t]=0;this.echoDelayOffsetEnd=null,this.echoShelfSampleL=0,this.echoShelfSampleR=0,this.echoShelfPrevInputL=0,this.echoShelfPrevInputR=0,this.reverbShelfSample0=0,this.reverbShelfSample1=0,this.reverbShelfSample2=0,this.reverbShelfSample3=0,this.reverbShelfPrevInput0=0,this.reverbShelfPrevInput1=0,this.reverbShelfPrevInput2=0,this.reverbShelfPrevInput3=0,this.awake=!1,this.flushingDelayLines=!1,this.deactivateAfterThisTick=!1,this.attentuationProgress=0,this.flushedSamples=0}resetAllEffects(){if(this.deactivate(),this.chorusDelayLineDirty){for(let t=0;t<this.chorusDelayLineL.length;t++)this.chorusDelayLineL[t]=0;for(let t=0;t<this.chorusDelayLineR.length;t++)this.chorusDelayLineR[t]=0}if(this.echoDelayLineDirty){for(let t=0;t<this.echoDelayLineL.length;t++)this.echoDelayLineL[t]=0;for(let t=0;t<this.echoDelayLineR.length;t++)this.echoDelayLineR[t]=0}if(this.reverbDelayLineDirty)for(let t=0;t<this.reverbDelayLine.length;t++)this.reverbDelayLine[t]=0;this.chorusPhase=0}compute(t,s,n,i,h){this.computed=!0,this.type=s.type,this.synthesizer=et.getInstrumentSynthFunction(s),this.unison=e.unisons[s.unison],this.chord=s.getChord(),this.noisePitchFilterMult=e.chipNoises[s.chipNoise].pitchFilterMult;let r=s.effects;0==s.distortion&&(r&=-9),s.pan==e.panCenter&&(r&=-5),0==s.chorus&&(r&=-3),0==s.echoSustain&&(r&=-65),0==s.reverb&&(r&=-2),this.effects=r,this.allocateNecessaryBuffers(t,s,n);const a=t.samplesPerSecond;this.updateWaves(s,a);const o=d(r),l=M(r),u=S(r),c=b(r),f=y(r),p=v(r);if(o){const t=Math.min(1,s.distortion/(e.distortionRange-1)),n=Math.min(1,s.distortion/(e.distortionRange-1)),h=Math.pow(1-.895*(Math.pow(20,t)-1)/19,2),r=Math.pow(1-.895*(Math.pow(20,n)-1)/19,2),a=(1+2*t)/e.distortionBaseVolume,o=(1+2*n)/e.distortionBaseVolume;this.distortion=h,this.distortionDelta=(r-h)/i,this.distortionDrive=a,this.distortionDriveDelta=(o-a)/i}if(l){const n=s.bitcrusherFreq,h=s.bitcrusherFreq,r=s.bitcrusherQuantization,o=s.bitcrusherQuantization,l=e.keys[t.song.key].basePitch,u=J.frequencyFromPitch(l+60)*Math.pow(2,(e.bitcrusherFreqRange-1-n)*e.bitcrusherOctaveStep),c=J.frequencyFromPitch(l+60)*Math.pow(2,(e.bitcrusherFreqRange-1-h)*e.bitcrusherOctaveStep),f=Math.min(1,u/a),p=Math.min(1,c/a);this.bitcrusherPhaseDelta=f,this.bitcrusherPhaseDeltaScale=Math.pow(p/f,1/i);const m=2*e.bitcrusherBaseVolume*Math.pow(2,1-Math.pow(2,.5*(e.bitcrusherQuantizationRange-1-r))),d=2*e.bitcrusherBaseVolume*Math.pow(2,1-Math.pow(2,.5*(e.bitcrusherQuantizationRange-1-o)));this.bitcrusherScale=m,this.bitcrusherScaleScale=Math.pow(d/m,1/i);const M=2*e.bitcrusherBaseVolume*Math.pow(1.5,e.bitcrusherQuantizationRange-1-r),S=2*e.bitcrusherBaseVolume*Math.pow(1.5,e.bitcrusherQuantizationRange-1-o);this.bitcrusherFoldLevel=M,this.bitcrusherFoldLevelScale=Math.pow(S/M,1/i)}let m=1;const g=s.eqFilter;for(let t=0;t<g.controlPointCount;t++){const e=g.controlPoints[t];e.toCoefficients(et.tempFilterStartCoefficients,a,1,1),e.toCoefficients(et.tempFilterEndCoefficients,a,1,1),this.eqFilters.length<=t&&(this.eqFilters[t]=new k),this.eqFilters[t].loadCoefficientsWithGradient(et.tempFilterStartCoefficients,et.tempFilterEndCoefficients,1/i,0==e.type),m*=e.getVolumeCompensationMult()}this.eqFilterCount=g.controlPointCount,m=Math.min(3,m);const I=et.instrumentVolumeToVolumeMult(s.volume);this.mixVolume=I;const P=I;this.mixVolumeDelta=(P-this.mixVolume)/i;let D=m,F=m,T=1,x=1;if(u){const n=(s.pan-e.panCenter)/e.panCenter,h=Math.max(-1,Math.min(1,n)),r=Math.max(-1,Math.min(1,n)),o=1.414*Math.cos((1+h)*Math.PI*.25),l=1.414*Math.cos((1-h)*Math.PI*.25),u=1.414*Math.cos((1+r)*Math.PI*.25),c=1.414*Math.cos((1-r)*Math.PI*.25),f=a*e.panDelaySecondsMax,p=h*f,m=r*f,d=Math.max(0,p),M=Math.max(0,-p),S=Math.max(0,m),b=Math.max(0,-m);this.panningVolumeL=o,this.panningVolumeR=l,this.panningVolumeDeltaL=(u-o)/i,this.panningVolumeDeltaR=(c-l)/i,this.panningOffsetL=this.panningDelayPos-d+t.panningDelayBufferSize,this.panningOffsetR=this.panningDelayPos-M+t.panningDelayBufferSize,this.panningOffsetDeltaL=(S-d)/i,this.panningOffsetDeltaR=(b-M)/i}if(c){let t=Math.min(1,s.chorus/(e.chorusRange-1)),n=Math.min(1,s.chorus/(e.chorusRange-1));t=.6*t+.4*Math.pow(t,6),n=.6*n+.4*Math.pow(n,6);const h=1/Math.sqrt(3*t*t+1),r=1/Math.sqrt(3*n*n+1);this.chorusVoiceMult=t,this.chorusVoiceMultDelta=(n-t)/i,this.chorusCombinedMult=h,this.chorusCombinedMultDelta=(r-h)/i}let O=0,L=0;if(f){const h=.9*Math.min(1,Math.pow(s.echoSustain/e.echoSustainRange,1.1)),r=.9*Math.min(1,Math.pow(s.echoSustain/e.echoSustainRange,1.1));this.echoMult=h,this.echoMultDelta=(r-h)/i,O=Math.max(h,r);const o=Math.round((s.echoDelay+1)*e.echoDelayStepTicks*n);null!=this.echoDelayOffsetEnd?this.echoDelayOffsetStart=this.echoDelayOffsetEnd:this.echoDelayOffsetStart=o,this.echoDelayOffsetEnd=o,L=.5*(this.echoDelayOffsetStart+this.echoDelayOffsetEnd)/a,this.echoDelayOffsetRatio=0,this.echoDelayOffsetRatioDelta=1/i;const l=2*Math.PI*e.echoShelfHz/t.samplesPerSecond;et.tempFilterStartCoefficients.highShelf1stOrder(l,e.echoShelfGain),this.echoShelfA1=et.tempFilterStartCoefficients.a[1],this.echoShelfB0=et.tempFilterStartCoefficients.b[0],this.echoShelfB1=et.tempFilterStartCoefficients.b[1]}let w=0;if(p){const n=.425*Math.min(1,Math.pow(s.reverb/e.reverbRange,.667)),h=.425*Math.min(1,Math.pow(s.reverb/e.reverbRange,.667));this.reverbMult=n,this.reverbMultDelta=(h-n)/i,w=Math.max(n,h);const r=2*Math.PI*e.reverbShelfHz/t.samplesPerSecond;et.tempFilterStartCoefficients.highShelf1stOrder(r,e.reverbShelfGain),this.reverbShelfA1=et.tempFilterStartCoefficients.a[1],this.reverbShelfB0=et.tempFilterStartCoefficients.b[0],this.reverbShelfB1=et.tempFilterStartCoefficients.b[1]}if(this.tonesAddedInThisTick)this.attentuationProgress=0,this.flushedSamples=0,this.flushingDelayLines=!1;else if(this.flushingDelayLines){D=0,F=0,T=0,x=0;let s=0;c&&(s+=t.chorusDelayBufferSize),f&&(s+=this.echoDelayLineL.length),p&&(s+=e.reverbDelayBufferSize),this.flushedSamples+=i,this.flushedSamples>=s&&(this.deactivateAfterThisTick=!0)}else{0==this.attentuationProgress||(D=0),F=0;const t=1/256,s=-Math.log2(t);let i=0;if(c&&(i+=e.chorusMaxDelay),f){const t=Math.pow(O,1/L);i+=-1/Math.log2(t)*s}if(p){const t=2*w,n=e.reverbDelayBufferSize/4/a,h=Math.pow(t,1/n);i+=-1/Math.log2(h)*s}const h=n/a/i,r=this.attentuationProgress+h;r>=1&&(x=0),this.attentuationProgress=r,this.attentuationProgress>=1&&(this.flushingDelayLines=!0)}this.eqFilterVolume=D,this.eqFilterVolumeDelta=(F-D)/i,this.delayInputMult=T,this.delayInputMultDelta=(x-T)/i}updateWaves(t,s){if(0==t.type)this.wave=e.chipWaves[t.chipWave].samples;else if(2==t.type)this.wave=h(t.chipNoise,P,g);else if(5==t.type)this.wave=this.harmonicsWave.getCustomWave(t.harmonicsWave,t.type);else if(7==t.type)this.wave=this.harmonicsWave.getCustomWave(t.harmonicsWave,t.type);else if(3==t.type)this.wave=this.spectrumWave.getCustomWave(t.spectrumWave,8);else if(4==t.type){for(let s=0;s<e.drumCount;s++)this.drumsetSpectrumWaves[s].getCustomWave(t.drumsetSpectrumWaves[s],Y.N(s));this.wave=null}else this.wave=null}getDrumsetWave(t){if(4==this.type)return this.drumsetSpectrumWaves[t].wave;throw new Error("Unhandled instrument type in getDrumsetWave")}static drumsetIndexReferenceDelta(t){return J.frequencyFromPitch(e.spectrumBasePitch+6*t)/44100}static N(t){return 15+Math.log2(Y.drumsetIndexReferenceDelta(t))}}class tt{constructor(){this.instruments=[],this.muted=!1,this.singleSeamlessInstrument=null}}class et{constructor(t=null){this.samplesPerSecond=44100,this.song=null,this.preferLowerLatency=!1,this.anticipatePoorPerformance=!1,this.liveInputDuration=0,this.liveInputStarted=!1,this.liveInputPitches=[],this.liveInputChannel=0,this.liveInputInstruments=[],this.loopRepeatCount=-1,this.volume=1,this.enableMetronome=!1,this.countInMetronome=!1,this.playheadInternal=0,this.bar=0,this.prevBar=null,this.nextBar=null,this.beat=0,this.part=0,this.tick=0,this.isAtStartOfTick=!0,this.tickSampleCountdown=0,this.isPlayingSong=!1,this.isRecording=!1,this.liveInputEndTime=0,this.browserAutomaticallyClearsAudioBuffer=!0,this.tempDrumSetControlPoint=new U,this.tempFrequencyResponse=new T,this.channels=[],this.tonePool=new D,this.tempMatchedPitchTones=Array(e.maxChordSize).fill(null),this.startedMetronome=!1,this.metronomeSamplesRemaining=-1,this.metronomeAmplitude=0,this.metronomePrevAmplitude=0,this.metronomeFilter=0,this.limit=0,this.tempMonoInstrumentSampleBuffer=null,this.audioCtx=null,this.scriptNode=null,this.audioProcessCallback=t=>{const e=t.outputBuffer,s=e.getChannelData(0),n=e.getChannelData(1);if(!this.browserAutomaticallyClearsAudioBuffer||0==s[0]&&0==n[0]&&0==s[e.length-1]&&0==n[e.length-1]||(this.browserAutomaticallyClearsAudioBuffer=!1),!this.browserAutomaticallyClearsAudioBuffer){const t=e.length;for(let e=0;e<t;e++)s[e]=0,n[e]=0}!this.isPlayingSong&&performance.now()>=this.liveInputEndTime?this.deactivateAudio():this.synthesize(s,n,e.length,this.isPlayingSong)},this.computeDelayBufferSizes(),null!=t&&this.setSong(t)}syncSongState(){const t=this.song.getChannelCount();for(let e=this.channels.length;e<t;e++)this.channels[e]=new tt;this.channels.length=t;for(let e=0;e<t;e++){const t=this.song.channels[e],s=this.channels[e];for(let e=s.instruments.length;e<t.instruments.length;e++)s.instruments[e]=new Y;if(s.instruments.length=t.instruments.length,s.muted!=t.muted&&(s.muted=t.muted,s.muted))for(const t of s.instruments)t.resetAllEffects()}}warmUpSynthesizer(t){if(null!=t){this.syncSongState();const e=this.getSamplesPerTick();for(let s=0;s<t.getChannelCount();s++)for(let n=0;n<t.channels[s].instruments.length;n++){const i=t.channels[s].instruments[n],h=this.channels[s].instruments[n];et.getInstrumentSynthFunction(i),h.updateWaves(i,this.samplesPerSecond),h.allocateNecessaryBuffers(this,i,e)}}}static operatorAmplitudeCurve(t){return(Math.pow(16,t/15)-1)/15}get playing(){return this.isPlayingSong}get recording(){return this.isRecording}get playhead(){return this.playheadInternal}set playhead(t){if(null!=this.song){this.playheadInternal=Math.max(0,Math.min(this.song.barCount,t));let s=this.playheadInternal;this.bar=Math.floor(s),s=this.song.beatsPerBar*(s-this.bar),this.beat=Math.floor(s),s=e.partsPerBeat*(s-this.beat),this.part=Math.floor(s),s=e.ticksPerPart*(s-this.part),this.tick=Math.floor(s),this.tickSampleCountdown=0,this.isAtStartOfTick=!0,this.prevBar=null}}getSamplesPerBar(){if(null==this.song)throw new Error;return this.getSamplesPerTick()*e.ticksPerPart*e.partsPerBeat*this.song.beatsPerBar}getTicksIntoBar(){return(this.beat*e.partsPerBeat+this.part)*e.ticksPerPart+this.tick}getCurrentPart(){return this.beat*e.partsPerBeat+this.part}getTotalBars(t,e){if(null==this.song)throw new Error;let s=this.song.loopLength*(this.loopRepeatCount+1);return t&&(s+=this.song.loopStart),e&&(s+=this.song.barCount-(this.song.loopStart+this.song.loopLength)),s}setSong(t){"string"==typeof t?this.song=new $(t):t instanceof $&&(this.song=t),this.prevBar=null}computeDelayBufferSizes(){this.panningDelayBufferSize=et.fittingPowerOfTwo(this.samplesPerSecond*e.panDelaySecondsMax),this.panningDelayBufferMask=this.panningDelayBufferSize-1,this.chorusDelayBufferSize=et.fittingPowerOfTwo(this.samplesPerSecond*e.chorusMaxDelay),this.chorusDelayBufferMask=this.chorusDelayBufferSize-1}activateAudio(){const t=this.anticipatePoorPerformance?this.preferLowerLatency?2048:4096:this.preferLowerLatency?512:2048;if(null==this.audioCtx||null==this.scriptNode||this.scriptNode.bufferSize!=t){null!=this.scriptNode&&this.deactivateAudio();const e=this.anticipatePoorPerformance?this.preferLowerLatency?"balanced":"playback":this.preferLowerLatency?"interactive":"balanced";this.audioCtx=this.audioCtx||new(window.AudioContext||window.webkitAudioContext)({latencyHint:e}),this.samplesPerSecond=this.audioCtx.sampleRate,this.scriptNode=this.audioCtx.createScriptProcessor?this.audioCtx.createScriptProcessor(t,0,2):this.audioCtx.createJavaScriptNode(t,0,2),this.scriptNode.onaudioprocess=this.audioProcessCallback,this.scriptNode.channelCountMode="explicit",this.scriptNode.channelInterpretation="speakers",this.scriptNode.connect(this.audioCtx.destination),this.computeDelayBufferSizes()}this.audioCtx.resume()}deactivateAudio(){null!=this.audioCtx&&null!=this.scriptNode&&(this.scriptNode.disconnect(this.audioCtx.destination),this.scriptNode=null,this.audioCtx.close&&this.audioCtx.close(),this.audioCtx=null)}maintainLiveInput(){this.activateAudio(),this.liveInputEndTime=performance.now()+1e4}play(){this.isPlayingSong||(this.isPlayingSong=!0,this.warmUpSynthesizer(this.song),this.activateAudio())}pause(){this.isPlayingSong&&(this.isPlayingSong=!1,this.isRecording=!1)}startRecording(){this.preferLowerLatency=!0,this.isRecording=!0,this.play()}snapToStart(){this.bar=0,this.snapToBar()}goToBar(t){this.bar=t,this.playheadInternal=this.bar,this.prevBar=null}snapToBar(){this.playheadInternal=this.bar,this.beat=0,this.part=0,this.tick=0,this.tickSampleCountdown=0,this.isAtStartOfTick=!0,this.prevBar=null}resetEffects(){if(this.limit=0,this.freeAllTones(),null!=this.song)for(const t of this.channels)for(const e of t.instruments)e.resetAllEffects()}jumpIntoLoop(){if(this.song&&(this.bar<this.song.loopStart||this.bar>=this.song.loopStart+this.song.loopLength)){const t=this.bar;this.bar=this.song.loopStart,this.playheadInternal+=this.bar-t,this.prevBar=null}}goToNextBar(){if(!this.song)return;this.prevBar=this.bar;const t=this.bar;this.bar++,this.bar>=this.song.barCount&&(this.bar=0),this.playheadInternal+=this.bar-t}goToPrevBar(){if(!this.song)return;this.prevBar=null;const t=this.bar;this.bar--,(this.bar<0||this.bar>=this.song.barCount)&&(this.bar=this.song.barCount-1),this.playheadInternal+=this.bar-t}getNextBar(){let t=this.bar+1;return this.isRecording?t>=this.song.barCount&&(t=this.song.barCount-1):0!=this.loopRepeatCount&&t==this.song.loopStart+this.song.loopLength&&(t=this.song.loopStart),t}synthesize(t,s,n,i=!0){if(null==this.song){for(let e=0;e<n;e++)t[e]=0,s[e]=0;return void this.deactivateAudio()}const h=this.song,r=this.getSamplesPerTick();let a=!1;(this.tickSampleCountdown<=0||this.tickSampleCountdown>r)&&(this.tickSampleCountdown=r,this.isAtStartOfTick=!0),i&&(this.beat>=h.beatsPerBar&&(this.beat=0,this.part=0,this.tick=0,this.tickSampleCountdown=r,this.isAtStartOfTick=!0,this.prevBar=this.bar,this.bar=this.getNextBar(),this.bar<=this.prevBar&&this.loopRepeatCount>0&&this.loopRepeatCount--),this.bar>=h.barCount&&(this.bar=0,-1!=this.loopRepeatCount&&(a=!0,this.pause()))),this.syncSongState(),(null==this.tempMonoInstrumentSampleBuffer||this.tempMonoInstrumentSampleBuffer.length<n)&&(this.tempMonoInstrumentSampleBuffer=new Float32Array(n));const o=+this.volume,l=1-Math.pow(.5,4/this.samplesPerSecond),u=1-Math.pow(.5,4e3/this.samplesPerSecond);let c=+this.limit,f=0;for(;f<n&&!a;){this.nextBar=this.getNextBar(),this.nextBar>=h.barCount&&(this.nextBar=null);const p=n-f,m=Math.ceil(this.tickSampleCountdown),d=Math.min(m,p),M=f+d;for(let n=0;n<h.getChannelCount();n++){const a=h.channels[n],o=this.channels[n];this.isAtStartOfTick&&(this.determineCurrentActiveTones(h,n,r,i&&!this.countInMetronome),this.determineLiveInputTones(h,n,r));for(let i=0;i<a.instruments.length;i++){const l=a.instruments[i],u=o.instruments[i];if(this.isAtStartOfTick){let t=u.activeTones.count()+u.liveInputTones.count();for(let s=0;s<u.releasedTones.count();s++){const i=u.releasedTones.get(s);if(i.ticksSinceReleased>=Math.abs(l.getFadeOutTicks())){this.freeReleasedTone(u,s),s--;continue}const a=t>=e.maximumTonesPerChannel;this.computeTone(h,n,r,i,!0,a),t++}u.awake&&(u.computed||u.compute(this,l,r,Math.ceil(r),null),u.computed=!1)}for(let t=0;t<u.activeTones.count();t++){const e=u.activeTones.get(t);this.playTone(n,f,d,e)}for(let t=0;t<u.liveInputTones.count();t++){const e=u.liveInputTones.get(t);this.playTone(n,f,d,e)}for(let t=0;t<u.releasedTones.count();t++){const e=u.releasedTones.get(t);this.playTone(n,f,d,e)}u.awake&&et.effectsSynth(this,t,s,f,d,u)}}if(this.enableMetronome||this.countInMetronome)if(0==this.part){if(!this.startedMetronome){const t=h.beatsPerBar>4&&h.beatsPerBar%2==0&&this.beat==h.beatsPerBar/2,e=0==this.beat?8:t?6:4,s=0==this.beat?1600:t?1200:800,n=0==this.beat?.06:t?.05:.04,i=this.samplesPerSecond/s,r=2*Math.PI/i;this.metronomeSamplesRemaining=Math.floor(i*e),this.metronomeFilter=2*Math.cos(r),this.metronomeAmplitude=n*Math.sin(r),this.metronomePrevAmplitude=0,this.startedMetronome=!0}if(this.metronomeSamplesRemaining>0){const e=Math.min(M,f+this.metronomeSamplesRemaining);this.metronomeSamplesRemaining-=e-f;for(let n=f;n<e;n++){t[n]+=this.metronomeAmplitude,s[n]+=this.metronomeAmplitude;const e=this.metronomeFilter*this.metronomeAmplitude-this.metronomePrevAmplitude;this.metronomePrevAmplitude=this.metronomeAmplitude,this.metronomeAmplitude=e}}}else this.startedMetronome=!1;for(let e=f;e<M;e++){const n=t[e],i=s[e],h=Math.max(Math.abs(n),Math.abs(i));c+=(h-c)*(c<h?u:l*(1+c));const r=o/(c>=1?1.05*c:.8*c+.25);t[e]=n*r,s[e]=i*r}if(f+=d,this.isAtStartOfTick=!1,this.tickSampleCountdown-=d,this.tickSampleCountdown<=0){this.isAtStartOfTick=!0;for(const t of this.channels)for(const e of t.instruments){for(let t=0;t<e.releasedTones.count();t++){const s=e.releasedTones.get(t);s.isOnLastTick?(this.freeReleasedTone(e,t),t--):s.ticksSinceReleased++}e.deactivateAfterThisTick&&e.deactivate(),e.tonesAddedInThisTick=!1}this.tick++,this.tickSampleCountdown+=r,this.tick==e.ticksPerPart&&(this.tick=0,this.part++,this.liveInputDuration--,this.part==e.partsPerBeat&&(this.part=0,i&&(this.beat++,this.beat==h.beatsPerBar&&(this.beat=0,this.countInMetronome?this.countInMetronome=!1:(this.prevBar=this.bar,this.bar=this.getNextBar(),this.bar<=this.prevBar&&this.loopRepeatCount>0&&this.loopRepeatCount--,this.bar>=h.barCount&&(this.bar=0,-1!=this.loopRepeatCount&&(a=!0,this.resetEffects(),this.pause())))))))}}(!Number.isFinite(c)||Math.abs(c)<O)&&(c=0),this.limit=c,i&&!this.countInMetronome&&(this.playheadInternal=(((this.tick+1-this.tickSampleCountdown/r)/2+this.part)/e.partsPerBeat+this.beat)/h.beatsPerBar+this.bar)}freeTone(t){this.tonePool.pushBack(t)}newTone(){if(this.tonePool.count()>0){const t=this.tonePool.popBack();return t.freshlyAllocated=!0,t}return new X}releaseTone(t,e){t.releasedTones.pushFront(e),e.atNoteStart=!1,e.passedEndOfNote=!0}freeReleasedTone(t,e){this.freeTone(t.releasedTones.get(e)),t.releasedTones.remove(e)}freeAllTones(){for(const t of this.channels)for(const e of t.instruments){for(;e.activeTones.count()>0;)this.freeTone(e.activeTones.popBack());for(;e.releasedTones.count()>0;)this.freeTone(e.releasedTones.popBack());for(;e.liveInputTones.count()>0;)this.freeTone(e.liveInputTones.popBack())}}determineLiveInputTones(t,e,s){const n=t.channels[e],i=this.channels[e],h=this.liveInputPitches;for(let r=0;r<n.instruments.length;r++){const a=i.instruments[r],o=a.liveInputTones;let l=0;if(this.liveInputDuration>0&&e==this.liveInputChannel&&h.length>0&&-1!=this.liveInputInstruments.indexOf(r)){const i=n.instruments[r];if(i.getChord().singleTone){let n;o.count()<=l?(n=this.newTone(),o.pushBack(n)):!i.getTransition().isSeamless&&this.liveInputStarted?(this.releaseTone(a,o.get(l)),n=this.newTone(),o.set(l,n)):n=o.get(l),l++;for(let t=0;t<h.length;t++)n.pitches[t]=h[t];n.pitchCount=h.length,n.chordSize=1,n.instrumentIndex=r,n.note=n.prevNote=n.nextNote=null,n.atNoteStart=this.liveInputStarted,n.forceContinueAtStart=!1,n.forceContinueAtEnd=!1,this.computeTone(t,e,s,n,!1,!1)}else{this.moveTonesIntoOrderedTempMatchedList(o,h);for(let n=0;n<h.length;n++){let i;null!=this.tempMatchedPitchTones[l]?(i=this.tempMatchedPitchTones[l],this.tempMatchedPitchTones[l]=null,1==i.pitchCount&&i.pitches[0]==h[n]||(this.releaseTone(a,i),i=this.newTone()),o.pushBack(i)):(i=this.newTone(),o.pushBack(i)),l++,i.pitches[0]=h[n],i.pitchCount=1,i.chordSize=h.length,i.instrumentIndex=r,i.note=i.prevNote=i.nextNote=null,i.atNoteStart=this.liveInputStarted,i.forceContinueAtStart=!1,i.forceContinueAtEnd=!1,this.computeTone(t,e,s,i,!1,!1)}}}for(;o.count()>l;)this.releaseTone(a,o.popBack());this.clearTempMatchedPitchTones(l,a)}this.liveInputStarted=!1}adjacentPatternHasCompatibleInstrumentTransition(t,e,s,n,i,h,r,a,o,l){if(t.patternInstruments&&-1==n.instruments.indexOf(i)){if(s.instruments.length>1||n.instruments.length>1)return null;const t=e.instruments[n.instruments[0]];if(l)return t.getChord();const i=t.getTransition();return h.includeAdjacentPatterns&&i.includeAdjacentPatterns&&i.slides==h.slides?t.getChord():null}return l||h.includeAdjacentPatterns?r:null}static adjacentNotesHaveMatchingPitches(t,e){if(t.pitches.length!=e.pitches.length)return!1;const s=t.pins[t.pins.length-1].interval;for(const n of t.pitches)if(-1==e.pitches.indexOf(n+s))return!1;return!0}moveTonesIntoOrderedTempMatchedList(t,e){for(let s=0;s<t.count();s++){const n=t.get(s),i=n.pitches[0]+n.lastInterval;for(let h=0;h<e.length;h++)if(e[h]==i){this.tempMatchedPitchTones[h]=n,t.remove(s),s--;break}}for(;t.count()>0;){const e=t.popFront();for(let t=0;t<this.tempMatchedPitchTones.length;t++)if(null==this.tempMatchedPitchTones[t]){this.tempMatchedPitchTones[t]=e;break}}}determineCurrentActiveTones(t,s,n,i){const h=t.channels[s],r=this.channels[s],a=t.getPattern(s,this.bar),o=this.getCurrentPart(),l=this.tick+e.ticksPerPart*o;let u=null,c=null,f=null;if(i&&null!=a&&!h.muted&&(!this.isRecording||this.liveInputChannel!=s)){for(let t=0;t<a.notes.length;t++)if(a.notes[t].end<=o)c=a.notes[t];else if(a.notes[t].start<=o&&a.notes[t].end>o)u=a.notes[t];else if(a.notes[t].start>o){f=a.notes[t];break}null!=u&&(null!=c&&c.end!=u.start&&(c=null),null!=f&&f.start!=u.end&&(f=null))}if(null!=a&&(!t.layeredInstruments||1==h.instruments.length||t.patternInstruments&&1==a.instruments.length)){const e=t.patternInstruments?a.instruments[0]:0;if(null!=r.singleSeamlessInstrument&&r.singleSeamlessInstrument!=e&&r.singleSeamlessInstrument<r.instruments.length){const t=r.instruments[r.singleSeamlessInstrument],s=r.instruments[e];for(;t.activeTones.count()>0;)s.activeTones.pushFront(t.activeTones.popBack())}r.singleSeamlessInstrument=e}else r.singleSeamlessInstrument=null;for(let i=0;i<h.instruments.length;i++){const p=r.instruments[i],m=p.activeTones;let d=0;if(null!=u&&(!t.patternInstruments||-1!=a.instruments.indexOf(i))){const r=h.instruments[i];let M=c,S=f;const b=e.partsPerBeat*t.beatsPerBar,y=r.getTransition(),v=r.getChord();let g=!1,I=!1,P=0,D=0;if(0==u.start){let e=null==this.prevBar?null:t.getPattern(s,this.prevBar);if(null!=e){const s=e.notes.length<=0?null:e.notes[e.notes.length-1];if(null!=s&&s.end==b){const n=u.continuesLastPattern&&et.adjacentNotesHaveMatchingPitches(s,u),r=this.adjacentPatternHasCompatibleInstrumentTransition(t,h,a,e,i,y,v,u,s,n);null!=r&&(M=s,P=r.singleTone?1:M.pitches.length,g=n)}}}else null!=M&&(P=v.singleTone?1:M.pitches.length);if(u.end==b){let e=null==this.nextBar?null:t.getPattern(s,this.nextBar);if(null!=e){const s=e.notes.length<=0?null:e.notes[0];if(null!=s&&0==s.start){const n=s.continuesLastPattern&&et.adjacentNotesHaveMatchingPitches(u,s),r=this.adjacentPatternHasCompatibleInstrumentTransition(t,h,a,e,i,y,v,u,s,n);null!=r&&(S=s,D=r.singleTone?1:S.pitches.length,I=n)}}}else null!=S&&(D=v.singleTone?1:S.pitches.length);if(v.singleTone){const h=e.ticksPerPart*u.start==l;let r;if(m.count()<=d)r=this.newTone(),m.pushBack(r);else if(!h||(y.isSeamless||g)&&null!=M)r=m.get(d);else{const t=m.get(d);t.isOnLastTick?this.freeTone(t):this.releaseTone(p,t),r=this.newTone(),m.set(d,r)}d++;for(let t=0;t<u.pitches.length;t++)r.pitches[t]=u.pitches[t];r.pitchCount=u.pitches.length,r.chordSize=1,r.instrumentIndex=i,r.note=u,r.noteStartPart=u.start,r.noteEndPart=u.end,r.prevNote=M,r.nextNote=S,r.prevNotePitchIndex=0,r.nextNotePitchIndex=0,r.atNoteStart=h,r.passedEndOfNote=!1,r.forceContinueAtStart=g,r.forceContinueAtEnd=I,this.computeTone(t,s,n,r,!1,!1)}else{const h=r.getTransition();(h.isSeamless&&!h.slides&&0==v.strumParts||g)&&e.ticksPerPart*u.start==l&&null!=M&&this.moveTonesIntoOrderedTempMatchedList(m,u.pitches);let a=0;for(let r=0;r<u.pitches.length;r++){let c=P>r?M:null,f=u,b=D>r?S:null,y=f.start+a,F=!1;if(y>o){if(!(m.count()>r&&(h.isSeamless||g)&&null!=c))break;b=f,f=c,c=null,y=f.start+a,F=!0}let T=f.end;(h.isSeamless||g)&&null!=b&&(T=Math.min(e.partsPerBeat*this.song.beatsPerBar,T+a)),(h.continues||g)&&null!=c||(a+=v.strumParts);const k=e.ticksPerPart*y==l;let x;if(null!=this.tempMatchedPitchTones[d])x=this.tempMatchedPitchTones[d],this.tempMatchedPitchTones[d]=null,m.pushBack(x);else if(m.count()<=d)x=this.newTone(),m.pushBack(x);else if(!k||(h.isSeamless||g)&&null!=c)x=m.get(d);else{const t=m.get(d);t.isOnLastTick?this.freeTone(t):this.releaseTone(p,t),x=this.newTone(),m.set(d,x)}d++,x.pitches[0]=f.pitches[r],x.pitchCount=1,x.chordSize=f.pitches.length,x.instrumentIndex=i,x.note=f,x.noteStartPart=y,x.noteEndPart=T,x.prevNote=c,x.nextNote=b,x.prevNotePitchIndex=r,x.nextNotePitchIndex=r,x.atNoteStart=k,x.passedEndOfNote=F,x.forceContinueAtStart=g&&null!=c,x.forceContinueAtEnd=I&&null!=b,this.computeTone(t,s,n,x,!1,!1)}}}for(;m.count()>d;){const e=m.popBack(),n=t.channels[s];if(e.instrumentIndex<n.instruments.length&&!e.isOnLastTick){const t=r.instruments[e.instrumentIndex];this.releaseTone(t,e)}else this.freeTone(e)}this.clearTempMatchedPitchTones(d,p)}}clearTempMatchedPitchTones(t,e){for(let s=t;s<this.tempMatchedPitchTones.length;s++){const t=this.tempMatchedPitchTones[s];null!=t&&(t.isOnLastTick?this.freeTone(t):this.releaseTone(e,t),this.tempMatchedPitchTones[s]=null)}}playTone(t,e,s,n){const i=this.channels[t].instruments[n.instrumentIndex];i.synthesizer(this,e,s,n,i),n.envelopeComputer.clearEnvelopes()}static computeChordExpression(t){return 1/(.25*(t-1)+1)}computeTone(t,s,n,h,r,o){const l=Math.ceil(n),u=t.channels[s],d=this.channels[s],M=u.instruments[h.instrumentIndex],S=d.instruments[h.instrumentIndex];S.awake=!0,S.tonesAddedInThisTick=!0,S.computed||S.compute(this,M,n,l,h);const b=t.getChannelIsNoise(s),y=M.getTransition(),v=M.getChord(),g=v.singleTone?1:et.computeChordExpression(h.chordSize),I=b?e.noiseInterval:1,P=e.ticksPerPart*n/this.samplesPerSecond,D=1/this.samplesPerSecond,F=1/e.partsPerBeat,T=this.getTicksIntoBar(),x=T/e.ticksPerPart,O=(T+1)/e.ticksPerPart,L=this.getCurrentPart();let w=1;h.specialIntervalExpressionMult=1;let R=o,B=0,C=0,A=1,N=1,E=g,V=g,z=16,W=e.keys[t.key].basePitch,G=1,q=48;if(3==M.type)G=e.spectrumBaseExpression,b&&(W=e.spectrumBasePitch,G*=2),z=e.spectrumBasePitch,q=28;else if(4==M.type)W=e.spectrumBasePitch,G=e.drumsetBaseExpression,z=W;else if(2==M.type)W=e.chipNoises[M.chipNoise].basePitch,G=e.noiseBaseExpression,z=W,q=e.chipNoises[M.chipNoise].isSoft?24:60;else if(1==M.type)G=e.fmBaseExpression;else if(0==M.type)G=e.chipBaseExpression;else if(5==M.type)G=e.harmonicsBaseExpression;else if(6==M.type)G=e.pwmBaseExpression;else if(8==M.type)G=e.supersawBaseExpression;else{if(7!=M.type)throw new Error("Unknown instrument type in computeTone.");G=e.pickedStringBaseExpression}(h.atNoteStart&&!y.isSeamless&&!h.forceContinueAtStart||h.freshlyAllocated)&&h.reset(),h.freshlyAllocated=!1;for(let t=0;t<e.maxPitchOrOperatorCount;t++)h.phaseDeltas[t]=0,h.phaseDeltaScales[t]=0,h.operatorExpressions[t]=0,h.operatorExpressionDeltas[t]=0;if(h.expression=0,h.expressionDelta=0,r){const t=h.ticksSinceReleased,s=h.ticksSinceReleased+1;B=C=h.lastInterval;const n=Math.abs(M.getFadeOutTicks());A=et.noteSizeToVolumeMult((1-t/n)*e.noteSizeMax),N=et.noteSizeToVolumeMult((1-s/n)*e.noteSizeMax),o&&(N=0),h.ticksSinceReleased+1>=n&&(R=!0)}else if(null==h.note)A=N=1,h.lastInterval=0,h.ticksSinceReleased=0,h.liveInputSamplesHeld+=l;else{const t=h.note,s=h.nextNote,n=h.noteStartPart,i=h.noteEndPart,r=t.getEndPinIndex(L),a=t.pins[r-1],o=t.pins[r],l=n*e.ticksPerPart,u=i*e.ticksPerPart,c=(t.start+a.time)*e.ticksPerPart,f=(t.start+o.time)*e.ticksPerPart;h.ticksSinceReleased=0;const p=L*e.ticksPerPart+this.tick,m=p+1,d=p-l,S=m-l,b=Math.min(1,(p-c)/(f-c)),v=Math.min(1,(m-c)/(f-c));if(A=1,N=1,B=a.interval+(o.interval-a.interval)*b,C=a.interval+(o.interval-a.interval)*v,h.lastInterval=C,!y.isSeamless&&!h.forceContinueAtEnd||null==s){const t=-M.getFadeOutTicks();if(t>0){const e=u-l;A*=Math.min(1,(e-d)/t),N*=Math.min(1,(e-S)/t),m>=l+e&&(R=!0)}}}h.isOnLastTick=R;const j=h.envelopeComputer;j.computeEnvelopes(M,L,e.ticksPerPart*x,n/this.samplesPerSecond,h);const K=h.envelopeComputer.envelopeStarts,H=h.envelopeComputer.envelopeEnds;if(null!=h.note&&y.slides){const t=h.prevNote,e=h.nextNote;if(null!=t){const e=t.pitches[h.prevNotePitchIndex]+t.pins[t.pins.length-1].interval-h.pitches[0];if(j.prevSlideStart&&(B+=e*j.prevSlideRatioStart),j.prevSlideEnd&&(C+=e*j.prevSlideRatioEnd),!v.singleTone){const e=t.pitches.length-h.chordSize;j.prevSlideStart&&(E=et.computeChordExpression(h.chordSize+e*j.prevSlideRatioStart)),j.prevSlideEnd&&(V=et.computeChordExpression(h.chordSize+e*j.prevSlideRatioEnd))}}if(null!=e){const t=e.pitches[h.nextNotePitchIndex]-(h.pitches[0]+h.note.pins[h.note.pins.length-1].interval);if(j.nextSlideStart&&(B+=t*j.nextSlideRatioStart),j.nextSlideEnd&&(C+=t*j.nextSlideRatioEnd),!v.singleTone){const t=e.pitches.length-h.chordSize;j.nextSlideStart&&(E=et.computeChordExpression(h.chordSize+t*j.nextSlideRatioStart)),j.nextSlideEnd&&(V=et.computeChordExpression(h.chordSize+t*j.nextSlideRatioEnd))}}}if(c(M.effects)){const t=e.justIntonationSemitones[M.pitchShift]/I;B+=t*K[14],C+=t*H[14]}if(f(M.effects)){const t=K[15],s=H[15];B+=et.detuneToCents((M.detune-e.detuneCenter)*t)*e.pitchesPerOctave/1200,C+=et.detuneToCents((M.detune-e.detuneCenter)*s)*e.pitchesPerOctave/1200}if(p(M.effects)){const t=e.vibratos[M.vibrato].delayTicks,s=e.vibratos[M.vibrato].amplitude;let n;if(null!=h.prevVibrato)n=h.prevVibrato;else{if(n=s*et.getLFOAmplitude(M,P*x)*K[16],t>0){const e=t-j.noteTicksStart;n*=Math.max(0,Math.min(1,1-e/2))}}let i=s*et.getLFOAmplitude(M,P*O)*H[16];if(t>0){const e=t-j.noteTicksEnd;i*=Math.max(0,Math.min(1,1-e/2))}h.prevVibrato=i,B+=n,C+=i}if(!y.isSeamless&&!h.forceContinueAtStart||null==h.prevNote){const t=M.getFadeInSeconds();t>0&&(A*=Math.min(1,j.noteSecondsStart/t),N*=Math.min(1,j.noteSecondsEnd/t))}4==M.type&&null==h.drumsetPitch&&(h.drumsetPitch=h.pitches[0],null!=h.note&&(h.drumsetPitch+=h.note.pickMainInterval()),h.drumsetPitch=Math.max(0,Math.min(e.drumCount-1,h.drumsetPitch)));let _=j.lowpassCutoffDecayVolumeCompensation;if(m(M.effects)){const t=M.noteFilter,e=K[1],s=H[1];for(let n=0;n<t.controlPointCount;n++){const i=K[17+n],r=H[17+n],a=K[25+n],o=H[25+n],u=t.controlPoints[n];u.toCoefficients(et.tempFilterStartCoefficients,this.samplesPerSecond,e*i,a),u.toCoefficients(et.tempFilterEndCoefficients,this.samplesPerSecond,s*r,o),h.noteFilters.length<=n&&(h.noteFilters[n]=new k),h.noteFilters[n].loadCoefficientsWithGradient(et.tempFilterStartCoefficients,et.tempFilterEndCoefficients,1/l,0==u.type),_*=u.getVolumeCompensationMult()}h.noteFilterCount=t.controlPointCount}else h.noteFilterCount=0;if(4==M.type){const t=M.getDrumsetEnvelope(h.drumsetPitch);_*=Q.getLowpassCutoffDecayVolumeCompensation(t);let e=Q.computeEnvelope(t,j.noteSecondsStart,F*x,j.noteSizeStart),s=Q.computeEnvelope(t,j.noteSecondsEnd,F*O,j.noteSizeEnd);if(j.prevSlideStart){e+=(Q.computeEnvelope(t,j.prevNoteSecondsStart,F*x,j.prevNoteSize)-e)*j.prevSlideRatioStart}if(j.prevSlideEnd){s+=(Q.computeEnvelope(t,j.prevNoteSecondsEnd,F*O,j.prevNoteSize)-s)*j.prevSlideRatioEnd}if(j.nextSlideStart){e+=(Q.computeEnvelope(t,0,F*x,j.nextNoteSize)-e)*j.nextSlideRatioStart}if(j.nextSlideEnd){s+=(Q.computeEnvelope(t,0,F*O,j.nextNoteSize)-s)*j.nextSlideRatioEnd}const n=this.tempDrumSetControlPoint;n.type=0,n.gain=U.getRoundedSettingValueFromLinearGain(.5),n.freq=U.getRoundedSettingValueFromHz(8e3),n.toCoefficients(et.tempFilterStartCoefficients,this.samplesPerSecond,e*(1+e),1),n.toCoefficients(et.tempFilterEndCoefficients,this.samplesPerSecond,s*(1+s),1),h.noteFilters.length==h.noteFilterCount&&(h.noteFilters[h.noteFilterCount]=new k),h.noteFilters[h.noteFilterCount].loadCoefficientsWithGradient(et.tempFilterStartCoefficients,et.tempFilterEndCoefficients,1/l,!0),h.noteFilterCount++}if(_=Math.min(3,_),1==M.type){let s=1,n=0,i=0;const r=v.arpeggiates;if(h.pitchCount>1&&r){const s=Math.floor((this.tick+this.part*e.ticksPerPart)/e.rhythms[t.rhythm].ticksPerArpeggio);i=h.pitches[a(h.pitchCount,t.rhythm,s)]-h.pitches[0]}const o=e.algorithms[M.algorithm].carrierCount;for(let t=0;t<e.operatorCount;t++){const a=e.algorithms[M.algorithm].associatedCarrier[t]-1,u=h.pitches[r?0:t<h.pitchCount?t:a<h.pitchCount?a:0],c=e.operatorFrequencies[M.operators[t].frequency].mult,f=e.operatorCarrierInterval[a]+i,p=W+(u+B)*I+f,m=W+(u+C)*I+f,d=J.frequencyFromPitch(p),S=J.frequencyFromPitch(m),b=e.operatorFrequencies[M.operators[t].frequency].hzOffset,y=c*d+b,v=c*S+b,g=K[5+t],P=H[5+t];let F,T;1!=g||1!=P?(F=Math.pow(2,Math.log2(y/d)*g)*d,T=Math.pow(2,Math.log2(v/S)*P)*S):(F=y,T=v),h.phaseDeltas[t]=F*D,h.phaseDeltaScales[t]=Math.pow(T/F,1/l);const k=et.operatorAmplitudeCurve(M.operators[t].amplitude),x=k*e.operatorFrequencies[M.operators[t].frequency].amplitudeSign;let O=x,L=x;if(t<o){let e;e=null!=h.prevPitchExpressions[t]?h.prevPitchExpressions[t]:Math.pow(2,-(p-z)/q);const s=Math.pow(2,-(m-z)/q);h.prevPitchExpressions[t]=s,O*=e,L*=s,n+=k}else O*=1.5*e.sineWaveLength,L*=1.5*e.sineWaveLength,s*=1-Math.min(1,M.operators[t].amplitude/15);O*=K[9+t],L*=H[9+t],h.operatorExpressions[t]=O,h.operatorExpressionDeltas[t]=(L-O)/l}s*=(Math.pow(2,2-1.4*M.feedbackAmplitude/15)-1)/3,s*=1-Math.min(1,Math.max(0,n-1)/2),s=1+3*s;const u=G*s*_*A*E*K[0],c=G*s*_*N*V*H[0];h.expression=u,h.expressionDelta=(c-u)/l;const f=.3*e.sineWaveLength*M.feedbackAmplitude/15;let p=f*K[13],m=f*H[13];h.feedbackMult=p,h.feedbackDelta=(m-p)/l}else{const s=Math.pow(2,(C-B)*I/12),n=Math.pow(s,1/l);let r=h.pitches[0];if(h.pitchCount>1&&(v.arpeggiates||v.customInterval)){const s=Math.floor((this.tick+this.part*e.ticksPerPart)/e.rhythms[t.rhythm].ticksPerArpeggio);if(v.customInterval){const e=h.pitches[1+a(h.pitchCount-1,t.rhythm,s)]-h.pitches[0];w=Math.pow(2,e/12),h.specialIntervalExpressionMult=Math.pow(2,-e/q)}else r=h.pitches[a(h.pitchCount,t.rhythm,s)]}const o=W+(r+B)*I,u=W+(r+C)*I;let c;c=null!=h.prevPitchExpressions[0]?h.prevPitchExpressions[0]:Math.pow(2,-(o-z)/q);const f=Math.pow(2,-(u-z)/q);h.prevPitchExpressions[0]=f;let p=G*_;if(2==M.type&&(p*=e.chipNoises[M.chipNoise].expression),0==M.type&&(p*=e.chipWaves[M.chipWave].expression),6==M.type){const t=i(M.pulseWidth),e=t*K[2],s=t*H[2];h.pulseWidth=e,h.pulseWidthDelta=(s-e)/l}7==M.type&&(p*=Math.pow(2,.7*(1-M.stringSustain/(e.stringSustainRange-1))));const m=J.frequencyFromPitch(o);if(0==M.type||5==M.type||7==M.type){const t=e.unisons[M.unison],s=7==M.type?1:t.voices/2;p*=t.expression*s;const i=K[4],r=H[4],a=Math.pow(2,(t.offset+t.spread)*i/12),o=Math.pow(2,(t.offset+t.spread)*r/12),u=Math.pow(2,(t.offset-t.spread)*i/12)*w,c=Math.pow(2,(t.offset-t.spread)*r/12)*w;h.phaseDeltas[0]=m*D*a,h.phaseDeltas[1]=m*D*u,h.phaseDeltaScales[0]=n*Math.pow(o/a,1/l),h.phaseDeltaScales[1]=n*Math.pow(c/u,1/l)}else h.phaseDeltas[0]=m*D,h.phaseDeltaScales[0]=n;let d=1,b=1;if(8==M.type){const t=1/Math.sqrt(e.supersawVoiceCount),n=M.supersawDynamism/e.supersawDynamismMax,r=1-Math.pow(Math.max(0,1-n*K[33]),.2),a=1-Math.pow(Math.max(0,1-n*H[33]),.2),o=Math.pow(2,Math.log2(t)*r),u=Math.pow(2,Math.log2(t)*a),c=Math.sqrt((1/Math.pow(o,2)-1)/(e.supersawVoiceCount-1)),f=Math.sqrt((1/Math.pow(u,2)-1)/(e.supersawVoiceCount-1));h.supersawDynamism=c,h.supersawDynamismDelta=(f-c)/l;const p=-1==h.supersawDelayIndex;if(p){let t=0;for(let s=0;s<e.supersawVoiceCount;s++)h.phases[s]=t,t+=-Math.log(Math.random());const s=1+(e.supersawVoiceCount-1)*c;let n=0;for(let s=0;s<e.supersawVoiceCount;s++){const e=0==s?1:c,i=h.phases[s]/t;h.phases[s]=i,n+=(i-.5)*e}let i=1,r=0;for(let t=e.supersawVoiceCount-1;t>=0;t--){const e=1-h.phases[t],a=e-r;if(n<0){const t=-n/s;if(t<a){i=r+t;break}}n+=a*s-(0==t?1:c),r=e}for(let t=0;t<e.supersawVoiceCount;t++)h.phases[t]+=i;for(let t=1;t<e.supersawVoiceCount-1;t++){const s=t+Math.floor(Math.random()*(e.supersawVoiceCount-t)),n=h.phases[t];h.phases[t]=h.phases[s],h.phases[s]=n}}const S=M.supersawSpread/e.supersawSpreadMax,y=.5*(S*K[34]+S*H[34]),v=Math.pow(1-Math.sqrt(Math.max(0,1-y)),1.75);for(let t=0;t<e.supersawVoiceCount;t++){const s=0==t?0:Math.pow(((t+1>>1)-.5+.025*((2&t)-1))/(e.supersawVoiceCount>>1),1.1)*(2*(1&t)-1);h.supersawUnisonDetunes[t]=Math.pow(2,v*s/12)}const g=M.supersawShape/e.supersawShapeMax,I=g*K[35],P=g*H[35];h.supersawShape=I,h.supersawShapeDelta=(P-I)/l;const F=i(M.pulseWidth),T=F*K[2],k=F*H[2],x=null!=h.supersawPrevPhaseDelta?h.supersawPrevPhaseDelta:m*D,O=m*D*s;h.supersawPrevPhaseDelta=O;const L=T/x,w=k/O;h.supersawDelayLength=L,h.supersawDelayLengthDelta=(w-L)/l;const R=Math.ceil(Math.max(L,w))+2;if(null==h.supersawDelayLine||h.supersawDelayLine.length<=R){const t=Math.ceil(.5*this.samplesPerSecond/J.frequencyFromPitch(24)),e=new Float32Array(et.fittingPowerOfTwo(Math.max(t,R)));if(!p&&null!=h.supersawDelayLine){const t=h.supersawDelayLine.length-1>>0,s=h.supersawDelayIndex;for(let n=0;n<h.supersawDelayLine.length;n++)e[n]=h.supersawDelayLine[s+n&t]}h.supersawDelayLine=e,h.supersawDelayIndex=h.supersawDelayLine.length}else p&&(h.supersawDelayLine.fill(0),h.supersawDelayIndex=h.supersawDelayLine.length);const B=e.pwmBaseExpression/e.supersawBaseExpression;d*=(1+(B-1)*I)/Math.sqrt(1+(e.supersawVoiceCount-1)*c*c),b*=(1+(B-1)*P)/Math.sqrt(1+(e.supersawVoiceCount-1)*f*f)}const g=p*A*E*c*K[0]*d,P=p*N*V*f*H[0]*b;if(h.expression=g,h.expressionDelta=(P-g)/l,7==M.type){let t;if(null!=h.prevStringDecay)t=h.prevStringDecay;else{const s=h.envelopeComputer.envelopeStarts[3];t=1-Math.min(1,s*M.stringSustain/(e.stringSustainRange-1))}const s=h.envelopeComputer.envelopeEnds[3];let n=1-Math.min(1,s*M.stringSustain/(e.stringSustainRange-1));h.prevStringDecay=n;const i=e.unisons[M.unison];for(let t=h.pickedStrings.length;t<i.voices;t++)h.pickedStrings[t]=new Z;if(h.atNoteStart&&!y.continues&&!h.forceContinueAtStart)for(const t of h.pickedStrings)t.delayIndex=-1;for(let e=0;e<i.voices;e++)h.pickedStrings[e].update(this,S,h,e,l,t,n,M.stringSustainType)}}}static getLFOAmplitude(t,s){let n=0;for(const i of e.vibratos[t.vibrato].periodsSeconds)n+=Math.sin(2*Math.PI*s/i);return n}static getInstrumentSynthFunction(t){if(1==t.type){const s=t.algorithm+"_"+t.feedbackType;if(null==et.fmSynthFunctionCache[s]){const n=[];for(const s of et.fmSourceTemplate)if(-1!=s.indexOf("// CARRIER OUTPUTS")){const i=[];for(let s=0;s<e.algorithms[t.algorithm].carrierCount;s++)i.push("operator"+s+"Scaled");n.push(s.replace("/*operator#Scaled*/",i.join(" + ")))}else if(-1!=s.indexOf("// INSERT OPERATOR COMPUTATION HERE"))for(let s=e.operatorCount-1;s>=0;s--)for(const i of et.operatorSourceTemplate)if(-1!=i.indexOf("/* + operator@Scaled*/")){let h="";for(const n of e.algorithms[t.algorithm].modulatedBy[s])h+=" + operator"+(n-1)+"Scaled";const r=e.feedbacks[t.feedbackType].indices[s];if(r.length>0){h+=" + feedbackMult * (";const t=[];for(const e of r)t.push("operator"+(e-1)+"Output");h+=t.join(" + ")+")"}n.push(i.replace(/\#/g,s+"").replace("/* + operator@Scaled*/",h))}else n.push(i.replace(/\#/g,s+""));else if(-1!=s.indexOf("#"))for(let t=0;t<e.operatorCount;t++)n.push(s.replace(/\#/g,t+""));else n.push(s);const i="return (synth, bufferIndex, runLength, tone, instrument) => {"+n.join("\n")+"}";et.fmSynthFunctionCache[s]=new Function("Config","Synth",i)(e,et)}return et.fmSynthFunctionCache[s]}if(0==t.type)return et.chipSynth;if(5==t.type)return et.harmonicsSynth;if(6==t.type)return et.pulseWidthSynth;if(8==t.type)return et.supersawSynth;if(7==t.type)return et.pickedStringSynth;if(2==t.type)return et.noiseSynth;if(3==t.type)return et.spectrumSynth;if(4==t.type)return et.drumsetSynth;throw new Error("Unrecognized instrument type: "+t.type)}static chipSynth(t,e,s,n,i){const h=t.tempMonoInstrumentSampleBuffer,r=i.wave,a=r.length-1,o=n.specialIntervalExpressionMult*i.unison.sign;1!=i.unison.voices||i.chord.customInterval||(n.phases[1]=n.phases[0]);let l=n.phaseDeltas[0]*a,u=n.phaseDeltas[1]*a;const c=+n.phaseDeltaScales[0],f=+n.phaseDeltaScales[1];let p=+n.expression;const m=+n.expressionDelta;let d=n.phases[0]%1*a,M=n.phases[1]%1*a;const S=n.noteFilters,b=0|n.noteFilterCount;let y=+n.initialNoteFilterInput1,v=+n.initialNoteFilterInput2;const g=et.applyFilters,I=0|d,P=0|M,D=I%a,F=P%a,T=d-I,k=M-P;let x=+r[D],O=+r[F];x+=(r[D+1]-x)*T,O+=(r[F+1]-O)*k;const L=e+s;for(let t=e;t<L;t++){d+=l,M+=u;const e=0|d,s=0|M,n=e%a,i=s%a;let I=r[n],P=r[i];const D=d-e,F=M-s;I+=(r[n+1]-I)*D,P+=(r[i+1]-P)*F;const T=(I-x)/l,k=(P-O)/u;x=I,O=P;const L=T+k*o,w=g(L,y,v,b,S);v=y,y=L,l*=c,u*=f;const R=w*p;p+=m,h[t]+=R}n.phases[0]=d/a,n.phases[1]=M/a,n.phaseDeltas[0]=l/a,n.phaseDeltas[1]=u/a,n.expression=p,t.sanitizeFilters(S),n.initialNoteFilterInput1=y,n.initialNoteFilterInput2=v}static harmonicsSynth(t,e,s,n,i){const h=t.tempMonoInstrumentSampleBuffer,r=i.wave,a=r.length-1,o=n.specialIntervalExpressionMult*i.unison.sign;1!=i.unison.voices||i.chord.customInterval||(n.phases[1]=n.phases[0]);let l=n.phaseDeltas[0]*a,u=n.phaseDeltas[1]*a;const c=+n.phaseDeltaScales[0],f=+n.phaseDeltaScales[1];let p=+n.expression;const m=+n.expressionDelta;let d=n.phases[0]%1*a,M=n.phases[1]%1*a;const S=n.noteFilters,b=0|n.noteFilterCount;let y=+n.initialNoteFilterInput1,v=+n.initialNoteFilterInput2;const g=et.applyFilters,I=0|d,P=0|M,D=I%a,F=P%a,T=d-I,k=M-P;let x=+r[D],O=+r[F];x+=(r[D+1]-x)*T,O+=(r[F+1]-O)*k;const L=e+s;for(let t=e;t<L;t++){d+=l,M+=u;const e=0|d,s=0|M,n=e%a,i=s%a;let I=r[n],P=r[i];const D=d-e,F=M-s;I+=(r[n+1]-I)*D,P+=(r[i+1]-P)*F;const T=(I-x)/l,k=(P-O)/u;x=I,O=P;const L=T+k*o,w=g(L,y,v,b,S);v=y,y=L,l*=c,u*=f;const R=w*p;p+=m,h[t]+=R}n.phases[0]=d/a,n.phases[1]=M/a,n.phaseDeltas[0]=l/a,n.phaseDeltas[1]=u/a,n.expression=p,t.sanitizeFilters(S),n.initialNoteFilterInput1=y,n.initialNoteFilterInput2=v}static pickedStringSynth(t,s,n,i,h){const r=h.unison.voices;let a=et.pickedStringFunctionCache[r];if(null==a){let t="return (synth, bufferIndex, runLength, tone, instrumentState) => {";t+="\n\t\t\t\tconst data = synth.tempMonoInstrumentSampleBuffer;\n\t\t\t\t\n\t\t\t\tlet pickedString# = tone.pickedStrings[#];\n\t\t\t\tlet allPassSample# = +pickedString#.allPassSample;\n\t\t\t\tlet allPassPrevInput# = +pickedString#.allPassPrevInput;\n\t\t\t\tlet sustainFilterSample# = +pickedString#.sustainFilterSample;\n\t\t\t\tlet sustainFilterPrevOutput2# = +pickedString#.sustainFilterPrevOutput2;\n\t\t\t\tlet sustainFilterPrevInput1# = +pickedString#.sustainFilterPrevInput1;\n\t\t\t\tlet sustainFilterPrevInput2# = +pickedString#.sustainFilterPrevInput2;\n\t\t\t\tlet fractionalDelaySample# = +pickedString#.fractionalDelaySample;\n\t\t\t\tconst delayLine# = pickedString#.delayLine;\n\t\t\t\tconst delayBufferMask# = (delayLine#.length - 1) >> 0;\n\t\t\t\tlet delayIndex# = pickedString#.delayIndex|0;\n\t\t\t\tdelayIndex# = (delayIndex# & delayBufferMask#) + delayLine#.length;\n\t\t\t\tlet delayLength# = +pickedString#.prevDelayLength;\n\t\t\t\tconst delayLengthDelta# = +pickedString#.delayLengthDelta;\n\t\t\t\tlet allPassG# = +pickedString#.allPassG;\n\t\t\t\tlet sustainFilterA1# = +pickedString#.sustainFilterA1;\n\t\t\t\tlet sustainFilterA2# = +pickedString#.sustainFilterA2;\n\t\t\t\tlet sustainFilterB0# = +pickedString#.sustainFilterB0;\n\t\t\t\tlet sustainFilterB1# = +pickedString#.sustainFilterB1;\n\t\t\t\tlet sustainFilterB2# = +pickedString#.sustainFilterB2;\n\t\t\t\tconst allPassGDelta# = +pickedString#.allPassGDelta;\n\t\t\t\tconst sustainFilterA1Delta# = +pickedString#.sustainFilterA1Delta;\n\t\t\t\tconst sustainFilterA2Delta# = +pickedString#.sustainFilterA2Delta;\n\t\t\t\tconst sustainFilterB0Delta# = +pickedString#.sustainFilterB0Delta;\n\t\t\t\tconst sustainFilterB1Delta# = +pickedString#.sustainFilterB1Delta;\n\t\t\t\tconst sustainFilterB2Delta# = +pickedString#.sustainFilterB2Delta;\n\t\t\t\t\n\t\t\t\tlet expression = +tone.expression;\n\t\t\t\tconst expressionDelta = +tone.expressionDelta;\n\t\t\t\t\n\t\t\t\tconst unisonSign = tone.specialIntervalExpressionMult * instrumentState.unison.sign;\n\t\t\t\tconst delayResetOffset# = pickedString#.delayResetOffset|0;\n\t\t\t\t\n\t\t\t\tconst filters = tone.noteFilters;\n\t\t\t\tconst filterCount = tone.noteFilterCount|0;\n\t\t\t\tlet initialFilterInput1 = +tone.initialNoteFilterInput1;\n\t\t\t\tlet initialFilterInput2 = +tone.initialNoteFilterInput2;\n\t\t\t\tconst applyFilters = Synth.applyFilters;\n\t\t\t\t\n\t\t\t\tconst stopIndex = bufferIndex + runLength;\n\t\t\t\tfor (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\n\t\t\t\t\tconst targetSampleTime# = delayIndex# - delayLength#;\n\t\t\t\t\tconst lowerIndex# = (targetSampleTime# + 0.125) | 0; // Offset to improve stability of all-pass filter.\n\t\t\t\t\tconst upperIndex# = lowerIndex# + 1;\n\t\t\t\t\tconst fractionalDelay# = upperIndex# - targetSampleTime#;\n\t\t\t\t\tconst fractionalDelayG# = (1.0 - fractionalDelay#) / (1.0 + fractionalDelay#); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\n\t\t\t\t\tconst prevInput# = delayLine#[lowerIndex# & delayBufferMask#];\n\t\t\t\t\tconst input# = delayLine#[upperIndex# & delayBufferMask#];\n\t\t\t\t\tfractionalDelaySample# = fractionalDelayG# * input# + prevInput# - fractionalDelayG# * fractionalDelaySample#;\n\t\t\t\t\t\n\t\t\t\t\tallPassSample# = fractionalDelaySample# * allPassG# + allPassPrevInput# - allPassG# * allPassSample#;\n\t\t\t\t\tallPassPrevInput# = fractionalDelaySample#;\n\t\t\t\t\t\n\t\t\t\t\tconst sustainFilterPrevOutput1# = sustainFilterSample#;\n\t\t\t\t\tsustainFilterSample# = sustainFilterB0# * allPassSample# + sustainFilterB1# * sustainFilterPrevInput1# + sustainFilterB2# * sustainFilterPrevInput2# - sustainFilterA1# * sustainFilterSample# - sustainFilterA2# * sustainFilterPrevOutput2#;\n\t\t\t\t\tsustainFilterPrevOutput2# = sustainFilterPrevOutput1#;\n\t\t\t\t\tsustainFilterPrevInput2# = sustainFilterPrevInput1#;\n\t\t\t\t\tsustainFilterPrevInput1# = allPassSample#;\n\t\t\t\t\t\n\t\t\t\t\tdelayLine#[delayIndex# & delayBufferMask#] += sustainFilterSample#;\n\t\t\t\t\tdelayLine#[(delayIndex# + delayResetOffset#) & delayBufferMask#] = 0.0;\n\t\t\t\t\tdelayIndex#++;\n\t\t\t\t\t\n\t\t\t\t\tconst inputSample = (";const s=[];for(let t=0;t<r;t++)s.push("fractionalDelaySample"+t+(1==t?" * unisonSign":""));t+=s.join(" + "),t+=") * expression;\n\t\t\t\t\tconst sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\n\t\t\t\t\tinitialFilterInput2 = initialFilterInput1;\n\t\t\t\t\tinitialFilterInput1 = inputSample;\n\t\t\t\t\tdata[sampleIndex] += sample;\n\t\t\t\t\t\n\t\t\t\t\texpression += expressionDelta;\n\t\t\t\t\tdelayLength# += delayLengthDelta#;\n\t\t\t\t\tallPassG# += allPassGDelta#;\n\t\t\t\t\tsustainFilterA1# += sustainFilterA1Delta#;\n\t\t\t\t\tsustainFilterA2# += sustainFilterA2Delta#;\n\t\t\t\t\tsustainFilterB0# += sustainFilterB0Delta#;\n\t\t\t\t\tsustainFilterB1# += sustainFilterB1Delta#;\n\t\t\t\t\tsustainFilterB2# += sustainFilterB2Delta#;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Avoid persistent denormal or NaN values in the delay buffers and filter history.\n\t\t\t\tconst epsilon = (1.0e-24);\n\t\t\t\tif (!Number.isFinite(allPassSample#) || Math.abs(allPassSample#) < epsilon) allPassSample# = 0.0;\n\t\t\t\tif (!Number.isFinite(allPassPrevInput#) || Math.abs(allPassPrevInput#) < epsilon) allPassPrevInput# = 0.0;\n\t\t\t\tif (!Number.isFinite(sustainFilterSample#) || Math.abs(sustainFilterSample#) < epsilon) sustainFilterSample# = 0.0;\n\t\t\t\tif (!Number.isFinite(sustainFilterPrevOutput2#) || Math.abs(sustainFilterPrevOutput2#) < epsilon) sustainFilterPrevOutput2# = 0.0;\n\t\t\t\tif (!Number.isFinite(sustainFilterPrevInput1#) || Math.abs(sustainFilterPrevInput1#) < epsilon) sustainFilterPrevInput1# = 0.0;\n\t\t\t\tif (!Number.isFinite(sustainFilterPrevInput2#) || Math.abs(sustainFilterPrevInput2#) < epsilon) sustainFilterPrevInput2# = 0.0;\n\t\t\t\tif (!Number.isFinite(fractionalDelaySample#) || Math.abs(fractionalDelaySample#) < epsilon) fractionalDelaySample# = 0.0;\n\t\t\t\tpickedString#.allPassSample = allPassSample#;\n\t\t\t\tpickedString#.allPassPrevInput = allPassPrevInput#;\n\t\t\t\tpickedString#.sustainFilterSample = sustainFilterSample#;\n\t\t\t\tpickedString#.sustainFilterPrevOutput2 = sustainFilterPrevOutput2#;\n\t\t\t\tpickedString#.sustainFilterPrevInput1 = sustainFilterPrevInput1#;\n\t\t\t\tpickedString#.sustainFilterPrevInput2 = sustainFilterPrevInput2#;\n\t\t\t\tpickedString#.fractionalDelaySample = fractionalDelaySample#;\n\t\t\t\tpickedString#.delayIndex = delayIndex#;\n\t\t\t\tpickedString#.prevDelayLength = delayLength#;\n\t\t\t\tpickedString#.allPassG = allPassG#;\n\t\t\t\tpickedString#.sustainFilterA1 = sustainFilterA1#;\n\t\t\t\tpickedString#.sustainFilterA2 = sustainFilterA2#;\n\t\t\t\tpickedString#.sustainFilterB0 = sustainFilterB0#;\n\t\t\t\tpickedString#.sustainFilterB1 = sustainFilterB1#;\n\t\t\t\tpickedString#.sustainFilterB2 = sustainFilterB2#;\n\t\t\t\t\n\t\t\t\ttone.expression = expression;\n\t\t\t\t\n\t\t\t\tsynth.sanitizeFilters(filters);\n\t\t\t\ttone.initialNoteFilterInput1 = initialFilterInput1;\n\t\t\t\ttone.initialNoteFilterInput2 = initialFilterInput2;\n\t\t\t}",t=t.replace(/^.*\#.*$/gm,(t=>{const e=[];for(let s=0;s<r;s++)e.push(t.replace(/\#/g,String(s)));return e.join("\n")})),a=new Function("Config","Synth",t)(e,et),et.pickedStringFunctionCache[r]=a}a(t,s,n,i,h)}static effectsSynth(t,s,n,i,h,r){const a=d(r.effects),o=M(r.effects),l=r.eqFilterCount>0,u=S(r.effects),c=b(r.effects),f=y(r.effects),p=v(r.effects);let m=0;a&&(m|=1),m<<=1,o&&(m|=1),m<<=1,l&&(m|=1),m<<=1,u&&(m|=1),m<<=1,c&&(m|=1),m<<=1,f&&(m|=1),m<<=1,p&&(m|=1);let g=et.effectsFunctionCache[m];if(null==g){let t="return (synth, outputDataL, outputDataR, bufferIndex, runLength, instrumentState) => {";const s=c||p||f;t+="\n\t\t\t\tconst tempMonoInstrumentSampleBuffer = synth.tempMonoInstrumentSampleBuffer;\n\t\t\t\t\n\t\t\t\tlet mixVolume = +instrumentState.mixVolume;\n\t\t\t\tconst mixVolumeDelta = +instrumentState.mixVolumeDelta;",s&&(t+="\n\t\t\t\t\n\t\t\t\tlet delayInputMult = +instrumentState.delayInputMult;\n\t\t\t\tconst delayInputMultDelta = +instrumentState.delayInputMultDelta;"),a&&(t+="\n\t\t\t\t\n\t\t\t\tconst distortionBaseVolume = +Config.distortionBaseVolume;\n\t\t\t\tlet distortion = instrumentState.distortion;\n\t\t\t\tconst distortionDelta = instrumentState.distortionDelta;\n\t\t\t\tlet distortionDrive = instrumentState.distortionDrive;\n\t\t\t\tconst distortionDriveDelta = instrumentState.distortionDriveDelta;\n\t\t\t\tconst distortionFractionalResolution = 4.0;\n\t\t\t\tconst distortionOversampleCompensation = distortionBaseVolume / distortionFractionalResolution;\n\t\t\t\tconst distortionFractionalDelay1 = 1.0 / distortionFractionalResolution;\n\t\t\t\tconst distortionFractionalDelay2 = 2.0 / distortionFractionalResolution;\n\t\t\t\tconst distortionFractionalDelay3 = 3.0 / distortionFractionalResolution;\n\t\t\t\tconst distortionFractionalDelayG1 = (1.0 - distortionFractionalDelay1) / (1.0 + distortionFractionalDelay1); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\n\t\t\t\tconst distortionFractionalDelayG2 = (1.0 - distortionFractionalDelay2) / (1.0 + distortionFractionalDelay2); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\n\t\t\t\tconst distortionFractionalDelayG3 = (1.0 - distortionFractionalDelay3) / (1.0 + distortionFractionalDelay3); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\n\t\t\t\tconst distortionNextOutputWeight1 = Math.cos(Math.PI * distortionFractionalDelay1) * 0.5 + 0.5;\n\t\t\t\tconst distortionNextOutputWeight2 = Math.cos(Math.PI * distortionFractionalDelay2) * 0.5 + 0.5;\n\t\t\t\tconst distortionNextOutputWeight3 = Math.cos(Math.PI * distortionFractionalDelay3) * 0.5 + 0.5;\n\t\t\t\tconst distortionPrevOutputWeight1 = 1.0 - distortionNextOutputWeight1;\n\t\t\t\tconst distortionPrevOutputWeight2 = 1.0 - distortionNextOutputWeight2;\n\t\t\t\tconst distortionPrevOutputWeight3 = 1.0 - distortionNextOutputWeight3;\n\t\t\t\t\n\t\t\t\tlet distortionFractionalInput1 = +instrumentState.distortionFractionalInput1;\n\t\t\t\tlet distortionFractionalInput2 = +instrumentState.distortionFractionalInput2;\n\t\t\t\tlet distortionFractionalInput3 = +instrumentState.distortionFractionalInput3;\n\t\t\t\tlet distortionPrevInput = +instrumentState.distortionPrevInput;\n\t\t\t\tlet distortionNextOutput = +instrumentState.distortionNextOutput;"),o&&(t+="\n\t\t\t\t\n\t\t\t\tlet bitcrusherPrevInput = +instrumentState.bitcrusherPrevInput;\n\t\t\t\tlet bitcrusherCurrentOutput = +instrumentState.bitcrusherCurrentOutput;\n\t\t\t\tlet bitcrusherPhase = +instrumentState.bitcrusherPhase;\n\t\t\t\tlet bitcrusherPhaseDelta = +instrumentState.bitcrusherPhaseDelta;\n\t\t\t\tconst bitcrusherPhaseDeltaScale = +instrumentState.bitcrusherPhaseDeltaScale;\n\t\t\t\tlet bitcrusherScale = +instrumentState.bitcrusherScale;\n\t\t\t\tconst bitcrusherScaleScale = +instrumentState.bitcrusherScaleScale;\n\t\t\t\tlet bitcrusherFoldLevel = +instrumentState.bitcrusherFoldLevel;\n\t\t\t\tconst bitcrusherFoldLevelScale = +instrumentState.bitcrusherFoldLevelScale;"),l&&(t+="\n\t\t\t\t\n\t\t\t\tlet filters = instrumentState.eqFilters;\n\t\t\t\tconst filterCount = instrumentState.eqFilterCount|0;\n\t\t\t\tlet initialFilterInput1 = +instrumentState.initialEqFilterInput1;\n\t\t\t\tlet initialFilterInput2 = +instrumentState.initialEqFilterInput2;\n\t\t\t\tconst applyFilters = Synth.applyFilters;"),t+="\n\t\t\t\t\n\t\t\t\tlet eqFilterVolume = +instrumentState.eqFilterVolume;\n\t\t\t\tconst eqFilterVolumeDelta = +instrumentState.eqFilterVolumeDelta;",u&&(t+="\n\t\t\t\t\n\t\t\t\tconst panningMask = synth.panningDelayBufferMask >>> 0;\n\t\t\t\tconst panningDelayLine = instrumentState.panningDelayLine;\n\t\t\t\tlet panningDelayPos = instrumentState.panningDelayPos & panningMask;\n\t\t\t\tlet   panningVolumeL      = +instrumentState.panningVolumeL;\n\t\t\t\tlet   panningVolumeR      = +instrumentState.panningVolumeR;\n\t\t\t\tconst panningVolumeDeltaL = +instrumentState.panningVolumeDeltaL;\n\t\t\t\tconst panningVolumeDeltaR = +instrumentState.panningVolumeDeltaR;\n\t\t\t\tlet   panningOffsetL      = +instrumentState.panningOffsetL;\n\t\t\t\tlet   panningOffsetR      = +instrumentState.panningOffsetR;\n\t\t\t\tconst panningOffsetDeltaL = 1.0 - instrumentState.panningOffsetDeltaL;\n\t\t\t\tconst panningOffsetDeltaR = 1.0 - instrumentState.panningOffsetDeltaR;"),c&&(t+="\n\t\t\t\t\n\t\t\t\tconst chorusMask = synth.chorusDelayBufferMask >>> 0;\n\t\t\t\tconst chorusDelayLineL = instrumentState.chorusDelayLineL;\n\t\t\t\tconst chorusDelayLineR = instrumentState.chorusDelayLineR;\n\t\t\t\tinstrumentState.chorusDelayLineDirty = true;\n\t\t\t\tlet chorusDelayPos = instrumentState.chorusDelayPos & chorusMask;\n\t\t\t\t\n\t\t\t\tlet chorusVoiceMult = +instrumentState.chorusVoiceMult;\n\t\t\t\tconst chorusVoiceMultDelta = +instrumentState.chorusVoiceMultDelta;\n\t\t\t\tlet chorusCombinedMult = +instrumentState.chorusCombinedMult;\n\t\t\t\tconst chorusCombinedMultDelta = +instrumentState.chorusCombinedMultDelta;\n\t\t\t\t\n\t\t\t\tconst chorusDuration = +Config.chorusPeriodSeconds;\n\t\t\t\tconst chorusAngle = Math.PI * 2.0 / (chorusDuration * synth.samplesPerSecond);\n\t\t\t\tconst chorusRange = synth.samplesPerSecond * Config.chorusDelayRange;\n\t\t\t\tconst chorusOffset0 = synth.chorusDelayBufferSize - Config.chorusDelayOffsets[0][0] * chorusRange;\n\t\t\t\tconst chorusOffset1 = synth.chorusDelayBufferSize - Config.chorusDelayOffsets[0][1] * chorusRange;\n\t\t\t\tconst chorusOffset2 = synth.chorusDelayBufferSize - Config.chorusDelayOffsets[0][2] * chorusRange;\n\t\t\t\tconst chorusOffset3 = synth.chorusDelayBufferSize - Config.chorusDelayOffsets[1][0] * chorusRange;\n\t\t\t\tconst chorusOffset4 = synth.chorusDelayBufferSize - Config.chorusDelayOffsets[1][1] * chorusRange;\n\t\t\t\tconst chorusOffset5 = synth.chorusDelayBufferSize - Config.chorusDelayOffsets[1][2] * chorusRange;\n\t\t\t\tlet chorusPhase = instrumentState.chorusPhase % (Math.PI * 2.0);\n\t\t\t\tlet chorusTap0Index = chorusDelayPos + chorusOffset0 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[0][0]);\n\t\t\t\tlet chorusTap1Index = chorusDelayPos + chorusOffset1 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[0][1]);\n\t\t\t\tlet chorusTap2Index = chorusDelayPos + chorusOffset2 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[0][2]);\n\t\t\t\tlet chorusTap3Index = chorusDelayPos + chorusOffset3 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[1][0]);\n\t\t\t\tlet chorusTap4Index = chorusDelayPos + chorusOffset4 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[1][1]);\n\t\t\t\tlet chorusTap5Index = chorusDelayPos + chorusOffset5 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[1][2]);\n\t\t\t\tchorusPhase += chorusAngle * runLength;\n\t\t\t\tconst chorusTap0End = chorusDelayPos + chorusOffset0 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[0][0]) + runLength;\n\t\t\t\tconst chorusTap1End = chorusDelayPos + chorusOffset1 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[0][1]) + runLength;\n\t\t\t\tconst chorusTap2End = chorusDelayPos + chorusOffset2 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[0][2]) + runLength;\n\t\t\t\tconst chorusTap3End = chorusDelayPos + chorusOffset3 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[1][0]) + runLength;\n\t\t\t\tconst chorusTap4End = chorusDelayPos + chorusOffset4 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[1][1]) + runLength;\n\t\t\t\tconst chorusTap5End = chorusDelayPos + chorusOffset5 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[1][2]) + runLength;\n\t\t\t\tconst chorusTap0Delta = (chorusTap0End - chorusTap0Index) / runLength;\n\t\t\t\tconst chorusTap1Delta = (chorusTap1End - chorusTap1Index) / runLength;\n\t\t\t\tconst chorusTap2Delta = (chorusTap2End - chorusTap2Index) / runLength;\n\t\t\t\tconst chorusTap3Delta = (chorusTap3End - chorusTap3Index) / runLength;\n\t\t\t\tconst chorusTap4Delta = (chorusTap4End - chorusTap4Index) / runLength;\n\t\t\t\tconst chorusTap5Delta = (chorusTap5End - chorusTap5Index) / runLength;"),f&&(t+="\n\t\t\t\t\n\t\t\t\tlet echoMult = +instrumentState.echoMult;\n\t\t\t\tconst echoMultDelta = +instrumentState.echoMultDelta;\n\t\t\t\t\n\t\t\t\tconst echoDelayLineL = instrumentState.echoDelayLineL;\n\t\t\t\tconst echoDelayLineR = instrumentState.echoDelayLineR;\n\t\t\t\tconst echoMask = (echoDelayLineL.length - 1) >>> 0;\n\t\t\t\tinstrumentState.echoDelayLineDirty = true;\n\t\t\t\t\n\t\t\t\tlet echoDelayPos = instrumentState.echoDelayPos & echoMask;\n\t\t\t\tconst echoDelayOffsetStart = (echoDelayLineL.length - instrumentState.echoDelayOffsetStart) & echoMask;\n\t\t\t\tconst echoDelayOffsetEnd   = (echoDelayLineL.length - instrumentState.echoDelayOffsetEnd) & echoMask;\n\t\t\t\tlet echoDelayOffsetRatio = +instrumentState.echoDelayOffsetRatio;\n\t\t\t\tconst echoDelayOffsetRatioDelta = +instrumentState.echoDelayOffsetRatioDelta;\n\t\t\t\t\n\t\t\t\tconst echoShelfA1 = +instrumentState.echoShelfA1;\n\t\t\t\tconst echoShelfB0 = +instrumentState.echoShelfB0;\n\t\t\t\tconst echoShelfB1 = +instrumentState.echoShelfB1;\n\t\t\t\tlet echoShelfSampleL = +instrumentState.echoShelfSampleL;\n\t\t\t\tlet echoShelfSampleR = +instrumentState.echoShelfSampleR;\n\t\t\t\tlet echoShelfPrevInputL = +instrumentState.echoShelfPrevInputL;\n\t\t\t\tlet echoShelfPrevInputR = +instrumentState.echoShelfPrevInputR;"),p&&(t+="\n\t\t\t\t\n\t\t\t\tconst reverbMask = Config.reverbDelayBufferMask >>> 0; //TODO: Dynamic reverb buffer size.\n\t\t\t\tconst reverbDelayLine = instrumentState.reverbDelayLine;\n\t\t\t\tinstrumentState.reverbDelayLineDirty = true;\n\t\t\t\tlet reverbDelayPos = instrumentState.reverbDelayPos & reverbMask;\n\t\t\t\t\n\t\t\t\tlet reverb = +instrumentState.reverbMult;\n\t\t\t\tconst reverbDelta = +instrumentState.reverbMultDelta;\n\t\t\t\t\n\t\t\t\tconst reverbShelfA1 = +instrumentState.reverbShelfA1;\n\t\t\t\tconst reverbShelfB0 = +instrumentState.reverbShelfB0;\n\t\t\t\tconst reverbShelfB1 = +instrumentState.reverbShelfB1;\n\t\t\t\tlet reverbShelfSample0 = +instrumentState.reverbShelfSample0;\n\t\t\t\tlet reverbShelfSample1 = +instrumentState.reverbShelfSample1;\n\t\t\t\tlet reverbShelfSample2 = +instrumentState.reverbShelfSample2;\n\t\t\t\tlet reverbShelfSample3 = +instrumentState.reverbShelfSample3;\n\t\t\t\tlet reverbShelfPrevInput0 = +instrumentState.reverbShelfPrevInput0;\n\t\t\t\tlet reverbShelfPrevInput1 = +instrumentState.reverbShelfPrevInput1;\n\t\t\t\tlet reverbShelfPrevInput2 = +instrumentState.reverbShelfPrevInput2;\n\t\t\t\tlet reverbShelfPrevInput3 = +instrumentState.reverbShelfPrevInput3;"),t+="\n\t\t\t\t\n\t\t\t\tconst stopIndex = bufferIndex + runLength;\n\t\t\t\tfor (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\n\t\t\t\t\tlet sample = tempMonoInstrumentSampleBuffer[sampleIndex];\n\t\t\t\t\ttempMonoInstrumentSampleBuffer[sampleIndex] = 0.0;",a&&(t+="\n\t\t\t\t\t\n\t\t\t\t\tconst distortionReverse = 1.0 - distortion;\n\t\t\t\t\tconst distortionNextInput = sample * distortionDrive;\n\t\t\t\t\tsample = distortionNextOutput;\n\t\t\t\t\tdistortionNextOutput = distortionNextInput / (distortionReverse * Math.abs(distortionNextInput) + distortion);\n\t\t\t\t\tdistortionFractionalInput1 = distortionFractionalDelayG1 * distortionNextInput + distortionPrevInput - distortionFractionalDelayG1 * distortionFractionalInput1;\n\t\t\t\t\tdistortionFractionalInput2 = distortionFractionalDelayG2 * distortionNextInput + distortionPrevInput - distortionFractionalDelayG2 * distortionFractionalInput2;\n\t\t\t\t\tdistortionFractionalInput3 = distortionFractionalDelayG3 * distortionNextInput + distortionPrevInput - distortionFractionalDelayG3 * distortionFractionalInput3;\n\t\t\t\t\tconst distortionOutput1 = distortionFractionalInput1 / (distortionReverse * Math.abs(distortionFractionalInput1) + distortion);\n\t\t\t\t\tconst distortionOutput2 = distortionFractionalInput2 / (distortionReverse * Math.abs(distortionFractionalInput2) + distortion);\n\t\t\t\t\tconst distortionOutput3 = distortionFractionalInput3 / (distortionReverse * Math.abs(distortionFractionalInput3) + distortion);\n\t\t\t\t\tdistortionNextOutput += distortionOutput1 * distortionNextOutputWeight1 + distortionOutput2 * distortionNextOutputWeight2 + distortionOutput3 * distortionNextOutputWeight3;\n\t\t\t\t\tsample += distortionOutput1 * distortionPrevOutputWeight1 + distortionOutput2 * distortionPrevOutputWeight2 + distortionOutput3 * distortionPrevOutputWeight3;\n\t\t\t\t\tsample *= distortionOversampleCompensation;\n\t\t\t\t\tdistortionPrevInput = distortionNextInput;\n\t\t\t\t\tdistortion += distortionDelta;\n\t\t\t\t\tdistortionDrive += distortionDriveDelta;"),o&&(t+="\n\t\t\t\t\t\n\t\t\t\t\tbitcrusherPhase += bitcrusherPhaseDelta;\n\t\t\t\t\tif (bitcrusherPhase < 1.0) {\n\t\t\t\t\t\tbitcrusherPrevInput = sample;\n\t\t\t\t\t\tsample = bitcrusherCurrentOutput;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbitcrusherPhase = bitcrusherPhase % 1.0;\n\t\t\t\t\t\tconst ratio = bitcrusherPhase / bitcrusherPhaseDelta;\n\t\t\t\t\t\t\n\t\t\t\t\t\tconst lerpedInput = sample + (bitcrusherPrevInput - sample) * ratio;\n\t\t\t\t\t\tbitcrusherPrevInput = sample;\n\t\t\t\t\t\t\n\t\t\t\t\t\tconst bitcrusherWrapLevel = bitcrusherFoldLevel * 4.0;\n\t\t\t\t\t\tconst wrappedSample = (((lerpedInput + bitcrusherFoldLevel) % bitcrusherWrapLevel) + bitcrusherWrapLevel) % bitcrusherWrapLevel;\n\t\t\t\t\t\tconst foldedSample = bitcrusherFoldLevel - Math.abs(bitcrusherFoldLevel * 2.0 - wrappedSample);\n\t\t\t\t\t\tconst scaledSample = foldedSample / bitcrusherScale;\n\t\t\t\t\t\tconst oldValue = bitcrusherCurrentOutput;\n\t\t\t\t\t\tconst newValue = (((scaledSample > 0 ? scaledSample + 1 : scaledSample)|0)-.5) * bitcrusherScale;\n\t\t\t\t\t\t\n\t\t\t\t\t\tsample = oldValue + (newValue - oldValue) * ratio;\n\t\t\t\t\t\tbitcrusherCurrentOutput = newValue;\n\t\t\t\t\t}\n\t\t\t\t\tbitcrusherPhaseDelta *= bitcrusherPhaseDeltaScale;\n\t\t\t\t\tbitcrusherScale *= bitcrusherScaleScale;\n\t\t\t\t\tbitcrusherFoldLevel *= bitcrusherFoldLevelScale;"),l&&(t+="\n\t\t\t\t\t\n\t\t\t\t\tconst inputSample = sample;\n\t\t\t\t\tsample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\n\t\t\t\t\tinitialFilterInput2 = initialFilterInput1;\n\t\t\t\t\tinitialFilterInput1 = inputSample;"),t+="\n\t\t\t\t\t\n\t\t\t\t\tsample *= eqFilterVolume;\n\t\t\t\t\teqFilterVolume += eqFilterVolumeDelta;",t+=u?"\n\t\t\t\t\t\n\t\t\t\t\tpanningDelayLine[panningDelayPos] = sample;\n\t\t\t\t\tconst panningRatioL  = panningOffsetL % 1;\n\t\t\t\t\tconst panningRatioR  = panningOffsetR % 1;\n\t\t\t\t\tconst panningTapLA   = panningDelayLine[(panningOffsetL) & panningMask];\n\t\t\t\t\tconst panningTapLB   = panningDelayLine[(panningOffsetL + 1) & panningMask];\n\t\t\t\t\tconst panningTapRA   = panningDelayLine[(panningOffsetR) & panningMask];\n\t\t\t\t\tconst panningTapRB   = panningDelayLine[(panningOffsetR + 1) & panningMask];\n\t\t\t\t\tconst panningTapL    = panningTapLA + (panningTapLB - panningTapLA) * panningRatioL;\n\t\t\t\t\tconst panningTapR    = panningTapRA + (panningTapRB - panningTapRA) * panningRatioR;\n\t\t\t\t\tlet sampleL = panningTapL * panningVolumeL;\n\t\t\t\t\tlet sampleR = panningTapR * panningVolumeR;\n\t\t\t\t\tpanningDelayPos = (panningDelayPos + 1) & panningMask;\n\t\t\t\t\tpanningVolumeL += panningVolumeDeltaL;\n\t\t\t\t\tpanningVolumeR += panningVolumeDeltaR;\n\t\t\t\t\tpanningOffsetL += panningOffsetDeltaL;\n\t\t\t\t\tpanningOffsetR += panningOffsetDeltaR;":"\n\t\t\t\t\t\n\t\t\t\t\tlet sampleL = sample;\n\t\t\t\t\tlet sampleR = sample;",c&&(t+="\n\t\t\t\t\t\n\t\t\t\t\tconst chorusTap0Ratio = chorusTap0Index % 1;\n\t\t\t\t\tconst chorusTap1Ratio = chorusTap1Index % 1;\n\t\t\t\t\tconst chorusTap2Ratio = chorusTap2Index % 1;\n\t\t\t\t\tconst chorusTap3Ratio = chorusTap3Index % 1;\n\t\t\t\t\tconst chorusTap4Ratio = chorusTap4Index % 1;\n\t\t\t\t\tconst chorusTap5Ratio = chorusTap5Index % 1;\n\t\t\t\t\tconst chorusTap0A = chorusDelayLineL[(chorusTap0Index) & chorusMask];\n\t\t\t\t\tconst chorusTap0B = chorusDelayLineL[(chorusTap0Index + 1) & chorusMask];\n\t\t\t\t\tconst chorusTap1A = chorusDelayLineL[(chorusTap1Index) & chorusMask];\n\t\t\t\t\tconst chorusTap1B = chorusDelayLineL[(chorusTap1Index + 1) & chorusMask];\n\t\t\t\t\tconst chorusTap2A = chorusDelayLineL[(chorusTap2Index) & chorusMask];\n\t\t\t\t\tconst chorusTap2B = chorusDelayLineL[(chorusTap2Index + 1) & chorusMask];\n\t\t\t\t\tconst chorusTap3A = chorusDelayLineR[(chorusTap3Index) & chorusMask];\n\t\t\t\t\tconst chorusTap3B = chorusDelayLineR[(chorusTap3Index + 1) & chorusMask];\n\t\t\t\t\tconst chorusTap4A = chorusDelayLineR[(chorusTap4Index) & chorusMask];\n\t\t\t\t\tconst chorusTap4B = chorusDelayLineR[(chorusTap4Index + 1) & chorusMask];\n\t\t\t\t\tconst chorusTap5A = chorusDelayLineR[(chorusTap5Index) & chorusMask];\n\t\t\t\t\tconst chorusTap5B = chorusDelayLineR[(chorusTap5Index + 1) & chorusMask];\n\t\t\t\t\tconst chorusTap0 = chorusTap0A + (chorusTap0B - chorusTap0A) * chorusTap0Ratio;\n\t\t\t\t\tconst chorusTap1 = chorusTap1A + (chorusTap1B - chorusTap1A) * chorusTap1Ratio;\n\t\t\t\t\tconst chorusTap2 = chorusTap2A + (chorusTap2B - chorusTap2A) * chorusTap2Ratio;\n\t\t\t\t\tconst chorusTap3 = chorusTap3A + (chorusTap3B - chorusTap3A) * chorusTap3Ratio;\n\t\t\t\t\tconst chorusTap4 = chorusTap4A + (chorusTap4B - chorusTap4A) * chorusTap4Ratio;\n\t\t\t\t\tconst chorusTap5 = chorusTap5A + (chorusTap5B - chorusTap5A) * chorusTap5Ratio;\n\t\t\t\t\tchorusDelayLineL[chorusDelayPos] = sampleL * delayInputMult;\n\t\t\t\t\tchorusDelayLineR[chorusDelayPos] = sampleR * delayInputMult;\n\t\t\t\t\tsampleL = chorusCombinedMult * (sampleL + chorusVoiceMult * (chorusTap1 - chorusTap0 - chorusTap2));\n\t\t\t\t\tsampleR = chorusCombinedMult * (sampleR + chorusVoiceMult * (chorusTap4 - chorusTap3 - chorusTap5));\n\t\t\t\t\tchorusDelayPos = (chorusDelayPos + 1) & chorusMask;\n\t\t\t\t\tchorusTap0Index += chorusTap0Delta;\n\t\t\t\t\tchorusTap1Index += chorusTap1Delta;\n\t\t\t\t\tchorusTap2Index += chorusTap2Delta;\n\t\t\t\t\tchorusTap3Index += chorusTap3Delta;\n\t\t\t\t\tchorusTap4Index += chorusTap4Delta;\n\t\t\t\t\tchorusTap5Index += chorusTap5Delta;\n\t\t\t\t\tchorusVoiceMult += chorusVoiceMultDelta;\n\t\t\t\t\tchorusCombinedMult += chorusCombinedMultDelta;"),f&&(t+="\n\t\t\t\t\t\n\t\t\t\t\tconst echoTapStartIndex = (echoDelayPos + echoDelayOffsetStart) & echoMask;\n\t\t\t\t\tconst echoTapEndIndex   = (echoDelayPos + echoDelayOffsetEnd  ) & echoMask;\n\t\t\t\t\tconst echoTapStartL = echoDelayLineL[echoTapStartIndex];\n\t\t\t\t\tconst echoTapEndL   = echoDelayLineL[echoTapEndIndex];\n\t\t\t\t\tconst echoTapStartR = echoDelayLineR[echoTapStartIndex];\n\t\t\t\t\tconst echoTapEndR   = echoDelayLineR[echoTapEndIndex];\n\t\t\t\t\tconst echoTapL = (echoTapStartL + (echoTapEndL - echoTapStartL) * echoDelayOffsetRatio) * echoMult;\n\t\t\t\t\tconst echoTapR = (echoTapStartR + (echoTapEndR - echoTapStartR) * echoDelayOffsetRatio) * echoMult;\n\t\t\t\t\t\n\t\t\t\t\techoShelfSampleL = echoShelfB0 * echoTapL + echoShelfB1 * echoShelfPrevInputL - echoShelfA1 * echoShelfSampleL;\n\t\t\t\t\techoShelfSampleR = echoShelfB0 * echoTapR + echoShelfB1 * echoShelfPrevInputR - echoShelfA1 * echoShelfSampleR;\n\t\t\t\t\techoShelfPrevInputL = echoTapL;\n\t\t\t\t\techoShelfPrevInputR = echoTapR;\n\t\t\t\t\tsampleL += echoShelfSampleL;\n\t\t\t\t\tsampleR += echoShelfSampleR;\n\t\t\t\t\t\n\t\t\t\t\techoDelayLineL[echoDelayPos] = sampleL * delayInputMult;\n\t\t\t\t\techoDelayLineR[echoDelayPos] = sampleR * delayInputMult;\n\t\t\t\t\techoDelayPos = (echoDelayPos + 1) & echoMask;\n\t\t\t\t\techoDelayOffsetRatio += echoDelayOffsetRatioDelta;\n\t\t\t\t\techoMult += echoMultDelta;"),p&&(t+="\n\t\t\t\t\t\n\t\t\t\t\t// Reverb, implemented using a feedback delay network with a Hadamard matrix and lowpass filters.\n\t\t\t\t\t// good ratios:    0.555235 + 0.618033 + 0.818 +   1.0 = 2.991268\n\t\t\t\t\t// Delay lengths:  3041     + 3385     + 4481  +  5477 = 16384 = 2^14\n\t\t\t\t\t// Buffer offsets: 3041    -> 6426   -> 10907 -> 16384\n\t\t\t\t\tconst reverbDelayPos1 = (reverbDelayPos +  3041) & reverbMask;\n\t\t\t\t\tconst reverbDelayPos2 = (reverbDelayPos +  6426) & reverbMask;\n\t\t\t\t\tconst reverbDelayPos3 = (reverbDelayPos + 10907) & reverbMask;\n\t\t\t\t\tconst reverbSample0 = (reverbDelayLine[reverbDelayPos]);\n\t\t\t\t\tconst reverbSample1 = reverbDelayLine[reverbDelayPos1];\n\t\t\t\t\tconst reverbSample2 = reverbDelayLine[reverbDelayPos2];\n\t\t\t\t\tconst reverbSample3 = reverbDelayLine[reverbDelayPos3];\n\t\t\t\t\tconst reverbTemp0 = -(reverbSample0 + sampleL) + reverbSample1;\n\t\t\t\t\tconst reverbTemp1 = -(reverbSample0 + sampleR) - reverbSample1;\n\t\t\t\t\tconst reverbTemp2 = -reverbSample2 + reverbSample3;\n\t\t\t\t\tconst reverbTemp3 = -reverbSample2 - reverbSample3;\n\t\t\t\t\tconst reverbShelfInput0 = (reverbTemp0 + reverbTemp2) * reverb;\n\t\t\t\t\tconst reverbShelfInput1 = (reverbTemp1 + reverbTemp3) * reverb;\n\t\t\t\t\tconst reverbShelfInput2 = (reverbTemp0 - reverbTemp2) * reverb;\n\t\t\t\t\tconst reverbShelfInput3 = (reverbTemp1 - reverbTemp3) * reverb;\n\t\t\t\t\treverbShelfSample0 = reverbShelfB0 * reverbShelfInput0 + reverbShelfB1 * reverbShelfPrevInput0 - reverbShelfA1 * reverbShelfSample0;\n\t\t\t\t\treverbShelfSample1 = reverbShelfB0 * reverbShelfInput1 + reverbShelfB1 * reverbShelfPrevInput1 - reverbShelfA1 * reverbShelfSample1;\n\t\t\t\t\treverbShelfSample2 = reverbShelfB0 * reverbShelfInput2 + reverbShelfB1 * reverbShelfPrevInput2 - reverbShelfA1 * reverbShelfSample2;\n\t\t\t\t\treverbShelfSample3 = reverbShelfB0 * reverbShelfInput3 + reverbShelfB1 * reverbShelfPrevInput3 - reverbShelfA1 * reverbShelfSample3;\n\t\t\t\t\treverbShelfPrevInput0 = reverbShelfInput0;\n\t\t\t\t\treverbShelfPrevInput1 = reverbShelfInput1;\n\t\t\t\t\treverbShelfPrevInput2 = reverbShelfInput2;\n\t\t\t\t\treverbShelfPrevInput3 = reverbShelfInput3;\n\t\t\t\t\treverbDelayLine[reverbDelayPos1] = reverbShelfSample0 * delayInputMult;\n\t\t\t\t\treverbDelayLine[reverbDelayPos2] = reverbShelfSample1 * delayInputMult;\n\t\t\t\t\treverbDelayLine[reverbDelayPos3] = reverbShelfSample2 * delayInputMult;\n\t\t\t\t\treverbDelayLine[reverbDelayPos ] = reverbShelfSample3 * delayInputMult;\n\t\t\t\t\treverbDelayPos = (reverbDelayPos + 1) & reverbMask;\n\t\t\t\t\tsampleL += reverbSample1 + reverbSample2 + reverbSample3;\n\t\t\t\t\tsampleR += reverbSample0 + reverbSample2 - reverbSample3;\n\t\t\t\t\treverb += reverbDelta;"),t+="\n\t\t\t\t\t\n\t\t\t\t\toutputDataL[sampleIndex] += sampleL * mixVolume;\n\t\t\t\t\toutputDataR[sampleIndex] += sampleR * mixVolume;\n\t\t\t\t\tmixVolume += mixVolumeDelta;",s&&(t+="\n\t\t\t\t\t\n\t\t\t\t\tdelayInputMult += delayInputMultDelta;"),t+="\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinstrumentState.mixVolume = mixVolume;\n\t\t\t\tinstrumentState.eqFilterVolume = eqFilterVolume;\n\t\t\t\t\n\t\t\t\t// Avoid persistent denormal or NaN values in the delay buffers and filter history.\n\t\t\t\tconst epsilon = (1.0e-24);",s&&(t+="\n\t\t\t\t\n\t\t\t\tinstrumentState.delayInputMult = delayInputMult;"),a&&(t+="\n\t\t\t\t\n\t\t\t\tinstrumentState.distortion = distortion;\n\t\t\t\tinstrumentState.distortionDrive = distortionDrive;\n\t\t\t\t\n\t\t\t\tif (!Number.isFinite(distortionFractionalInput1) || Math.abs(distortionFractionalInput1) < epsilon) distortionFractionalInput1 = 0.0;\n\t\t\t\tif (!Number.isFinite(distortionFractionalInput2) || Math.abs(distortionFractionalInput2) < epsilon) distortionFractionalInput2 = 0.0;\n\t\t\t\tif (!Number.isFinite(distortionFractionalInput3) || Math.abs(distortionFractionalInput3) < epsilon) distortionFractionalInput3 = 0.0;\n\t\t\t\tif (!Number.isFinite(distortionPrevInput) || Math.abs(distortionPrevInput) < epsilon) distortionPrevInput = 0.0;\n\t\t\t\tif (!Number.isFinite(distortionNextOutput) || Math.abs(distortionNextOutput) < epsilon) distortionNextOutput = 0.0;\n\t\t\t\t\n\t\t\t\tinstrumentState.distortionFractionalInput1 = distortionFractionalInput1;\n\t\t\t\tinstrumentState.distortionFractionalInput2 = distortionFractionalInput2;\n\t\t\t\tinstrumentState.distortionFractionalInput3 = distortionFractionalInput3;\n\t\t\t\tinstrumentState.distortionPrevInput = distortionPrevInput;\n\t\t\t\tinstrumentState.distortionNextOutput = distortionNextOutput;"),o&&(t+="\n\t\t\t\t\t\n\t\t\t\tif (Math.abs(bitcrusherPrevInput) < epsilon) bitcrusherPrevInput = 0.0;\n\t\t\t\tif (Math.abs(bitcrusherCurrentOutput) < epsilon) bitcrusherCurrentOutput = 0.0;\n\t\t\t\tinstrumentState.bitcrusherPrevInput = bitcrusherPrevInput;\n\t\t\t\tinstrumentState.bitcrusherCurrentOutput = bitcrusherCurrentOutput;\n\t\t\t\tinstrumentState.bitcrusherPhase = bitcrusherPhase;\n\t\t\t\tinstrumentState.bitcrusherPhaseDelta = bitcrusherPhaseDelta;\n\t\t\t\tinstrumentState.bitcrusherScale = bitcrusherScale;\n\t\t\t\tinstrumentState.bitcrusherFoldLevel = bitcrusherFoldLevel;"),l&&(t+="\n\t\t\t\t\t\n\t\t\t\tsynth.sanitizeFilters(filters);\n\t\t\t\t// The filter input here is downstream from another filter so we\n\t\t\t\t// better make sure it's safe too.\n\t\t\t\tif (!(initialFilterInput1 < 100) || !(initialFilterInput2 < 100)) {\n\t\t\t\t\tinitialFilterInput1 = 0.0;\n\t\t\t\t\tinitialFilterInput2 = 0.0;\n\t\t\t\t}\n\t\t\t\tif (Math.abs(initialFilterInput1) < epsilon) initialFilterInput1 = 0.0;\n\t\t\t\tif (Math.abs(initialFilterInput2) < epsilon) initialFilterInput2 = 0.0;\n\t\t\t\tinstrumentState.initialEqFilterInput1 = initialFilterInput1;\n\t\t\t\tinstrumentState.initialEqFilterInput2 = initialFilterInput2;"),u&&(t+="\n\t\t\t\t\n\t\t\t\tSynth.sanitizeDelayLine(panningDelayLine, panningDelayPos, panningMask);\n\t\t\t\tinstrumentState.panningDelayPos = panningDelayPos;\n\t\t\t\tinstrumentState.panningVolumeL = panningVolumeL;\n\t\t\t\tinstrumentState.panningVolumeR = panningVolumeR;\n\t\t\t\tinstrumentState.panningOffsetL = panningOffsetL;\n\t\t\t\tinstrumentState.panningOffsetR = panningOffsetR;"),c&&(t+="\n\t\t\t\t\n\t\t\t\tSynth.sanitizeDelayLine(chorusDelayLineL, chorusDelayPos, chorusMask);\n\t\t\t\tSynth.sanitizeDelayLine(chorusDelayLineR, chorusDelayPos, chorusMask);\n\t\t\t\tinstrumentState.chorusPhase = chorusPhase;\n\t\t\t\tinstrumentState.chorusDelayPos = chorusDelayPos;\n\t\t\t\tinstrumentState.chorusVoiceMult = chorusVoiceMult;\n\t\t\t\tinstrumentState.chorusCombinedMult = chorusCombinedMult;"),f&&(t+="\n\t\t\t\t\n\t\t\t\tSynth.sanitizeDelayLine(echoDelayLineL, echoDelayPos, echoMask);\n\t\t\t\tSynth.sanitizeDelayLine(echoDelayLineR, echoDelayPos, echoMask);\n\t\t\t\tinstrumentState.echoDelayPos = echoDelayPos;\n\t\t\t\tinstrumentState.echoMult = echoMult;\n\t\t\t\tinstrumentState.echoDelayOffsetRatio = echoDelayOffsetRatio;\n\t\t\t\t\n\t\t\t\tif (!Number.isFinite(echoShelfSampleL) || Math.abs(echoShelfSampleL) < epsilon) echoShelfSampleL = 0.0;\n\t\t\t\tif (!Number.isFinite(echoShelfSampleR) || Math.abs(echoShelfSampleR) < epsilon) echoShelfSampleR = 0.0;\n\t\t\t\tif (!Number.isFinite(echoShelfPrevInputL) || Math.abs(echoShelfPrevInputL) < epsilon) echoShelfPrevInputL = 0.0;\n\t\t\t\tif (!Number.isFinite(echoShelfPrevInputR) || Math.abs(echoShelfPrevInputR) < epsilon) echoShelfPrevInputR = 0.0;\n\t\t\t\tinstrumentState.echoShelfSampleL = echoShelfSampleL;\n\t\t\t\tinstrumentState.echoShelfSampleR = echoShelfSampleR;\n\t\t\t\tinstrumentState.echoShelfPrevInputL = echoShelfPrevInputL;\n\t\t\t\tinstrumentState.echoShelfPrevInputR = echoShelfPrevInputR;"),p&&(t+="\n\t\t\t\t\n\t\t\t\tSynth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos        , reverbMask);\n\t\t\t\tSynth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos +  3041, reverbMask);\n\t\t\t\tSynth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos +  6426, reverbMask);\n\t\t\t\tSynth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos + 10907, reverbMask);\n\t\t\t\tinstrumentState.reverbDelayPos = reverbDelayPos;\n\t\t\t\tinstrumentState.reverbMult = reverb;\n\t\t\t\t\n\t\t\t\tif (!Number.isFinite(reverbShelfSample0) || Math.abs(reverbShelfSample0) < epsilon) reverbShelfSample0 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfSample1) || Math.abs(reverbShelfSample1) < epsilon) reverbShelfSample1 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfSample2) || Math.abs(reverbShelfSample2) < epsilon) reverbShelfSample2 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfSample3) || Math.abs(reverbShelfSample3) < epsilon) reverbShelfSample3 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput0) || Math.abs(reverbShelfPrevInput0) < epsilon) reverbShelfPrevInput0 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput1) || Math.abs(reverbShelfPrevInput1) < epsilon) reverbShelfPrevInput1 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput2) || Math.abs(reverbShelfPrevInput2) < epsilon) reverbShelfPrevInput2 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput3) || Math.abs(reverbShelfPrevInput3) < epsilon) reverbShelfPrevInput3 = 0.0;\n\t\t\t\tinstrumentState.reverbShelfSample0 = reverbShelfSample0;\n\t\t\t\tinstrumentState.reverbShelfSample1 = reverbShelfSample1;\n\t\t\t\tinstrumentState.reverbShelfSample2 = reverbShelfSample2;\n\t\t\t\tinstrumentState.reverbShelfSample3 = reverbShelfSample3;\n\t\t\t\tinstrumentState.reverbShelfPrevInput0 = reverbShelfPrevInput0;\n\t\t\t\tinstrumentState.reverbShelfPrevInput1 = reverbShelfPrevInput1;\n\t\t\t\tinstrumentState.reverbShelfPrevInput2 = reverbShelfPrevInput2;\n\t\t\t\tinstrumentState.reverbShelfPrevInput3 = reverbShelfPrevInput3;"),t+="}",g=new Function("Config","Synth",t)(e,et),et.effectsFunctionCache[m]=g}g(t,s,n,i,h,r)}static pulseWidthSynth(t,e,s,n,i){const h=t.tempMonoInstrumentSampleBuffer;let r=n.phaseDeltas[0];const a=+n.phaseDeltaScales[0];let o=+n.expression;const l=+n.expressionDelta;let u=n.phases[0]%1,c=n.pulseWidth;const f=n.pulseWidthDelta,p=n.noteFilters,m=0|n.noteFilterCount;let d=+n.initialNoteFilterInput1,M=+n.initialNoteFilterInput2;const S=et.applyFilters,b=e+s;for(let t=e;t<b;t++){const e=u%1,s=(u+c)%1;let n=s-e;if(e<r)n+=.5*((y=e/r)+y-y*y-1);else if(e>1-r){n+=.5*((y=(e-1)/r)+y+y*y+1)}if(s<r)n-=.5*((y=s/r)+y-y*y-1);else if(s>1-r){var y;n-=.5*((y=(s-1)/r)+y+y*y+1)}const i=n,b=S(i,d,M,m,p);M=d,d=i,u+=r,r*=a,c+=f;const v=b*o;o+=l,h[t]+=v}n.phases[0]=u,n.phaseDeltas[0]=r,n.expression=o,n.pulseWidth=c,t.sanitizeFilters(p),n.initialNoteFilterInput1=d,n.initialNoteFilterInput2=M}static supersawSynth(t,s,n,i,h){const r=t.tempMonoInstrumentSampleBuffer,a=0|e.supersawVoiceCount;let o=i.phaseDeltas[0];const l=+i.phaseDeltaScales[0];let u=+i.expression;const c=+i.expressionDelta;let f=i.phases,p=+i.supersawDynamism;const m=+i.supersawDynamismDelta,d=i.supersawUnisonDetunes;let M=+i.supersawShape;const S=+i.supersawShapeDelta;let b=+i.supersawDelayLength;const y=+i.supersawDelayLengthDelta,v=i.supersawDelayLine,g=v.length-1>>0;let I=0|i.supersawDelayIndex;I=(I&g)+v.length;const P=i.noteFilters,D=0|i.noteFilterCount;let F=+i.initialNoteFilterInput1,T=+i.initialNoteFilterInput2;const k=et.applyFilters,x=s+n;for(let t=s;t<x;t++){let e=(f[0]+o)%1,s=e-.5*(1+(a-1)*p);if(e<o)s-=.5*((O=e/o)+O-O*O-1);else if(e>1-o){var O;s-=.5*((O=(e-1)/o)+O+O*O+1)}f[0]=e;for(let t=1;t<a;t++){const e=o*d[t];let n=(f[t]+e)%1;if(s+=n*p,n<e){const t=n/e;s-=.5*(t+t-t*t-1)*p}else if(n>1-e){const t=(n-1)/e;s-=.5*(t+t+t*t+1)*p}f[t]=n}v[I&g]=s;const n=I-b,i=0|n,h=i+1,x=n-i,L=v[i&g];I++;const w=s-(L+(v[h&g]-L)*x)*M,R=k(w,F,T,D,P);T=F,F=w,o*=l,p+=m,M+=S,b+=y;const B=R*u;u+=c,r[t]+=B}i.phaseDeltas[0]=o,i.expression=u,i.supersawDynamism=p,i.supersawShape=M,i.supersawDelayLength=b,i.supersawDelayIndex=I,t.sanitizeFilters(P),i.initialNoteFilterInput1=F,i.initialNoteFilterInput2=T}static noiseSynth(t,s,n,i,h){const r=t.tempMonoInstrumentSampleBuffer,a=h.wave;let o=+i.phaseDeltas[0];const l=+i.phaseDeltaScales[0];let u=+i.expression;const c=+i.expressionDelta;let f=i.phases[0]%1*e.chipNoiseLength;0==i.phases[0]&&(f=Math.random()*e.chipNoiseLength);const p=e.chipNoiseLength-1;let m=+i.noiseSample;const d=i.noteFilters,M=0|i.noteFilterCount;let S=+i.initialNoteFilterInput1,b=+i.initialNoteFilterInput2;const y=et.applyFilters,v=Math.min(1,o*h.noisePitchFilterMult),g=s+n;for(let t=s;t<g;t++){m+=(a[f&p]-m)*v;const e=m,s=y(e,S,b,M,d);b=S,S=e,f+=o,o*=l;const n=s*u;u+=c,r[t]+=n}i.phases[0]=f/e.chipNoiseLength,i.phaseDeltas[0]=o,i.expression=u,i.noiseSample=m,t.sanitizeFilters(d),i.initialNoteFilterInput1=S,i.initialNoteFilterInput2=b}static spectrumSynth(t,s,n,i,h){const r=t.tempMonoInstrumentSampleBuffer,a=h.wave;let o=128*i.phaseDeltas[0];const l=+i.phaseDeltaScales[0];let u=+i.expression;const c=+i.expressionDelta;let f=+i.noiseSample;const p=i.noteFilters,m=0|i.noteFilterCount;let d=+i.initialNoteFilterInput1,M=+i.initialNoteFilterInput2;const S=et.applyFilters;let b=i.phases[0]%1*e.spectrumNoiseLength;0==i.phases[0]&&(b=et.findRandomZeroCrossing(a,e.spectrumNoiseLength)+o);const y=e.spectrumNoiseLength-1,v=Math.min(1,o),g=s+n;for(let t=s;t<g;t++){const e=0|b,s=e&y;let n=a[s];const i=b-e;n+=(a[s+1]-n)*i,f+=(n-f)*v;const h=f,g=S(h,d,M,m,p);M=d,d=h,b+=o,o*=l;const I=g*u;u+=c,r[t]+=I}i.phases[0]=b/e.spectrumNoiseLength,i.phaseDeltas[0]=o/128,i.expression=u,i.noiseSample=f,t.sanitizeFilters(p),i.initialNoteFilterInput1=d,i.initialNoteFilterInput2=M}static drumsetSynth(t,s,n,i,h){const r=t.tempMonoInstrumentSampleBuffer;let a=h.getDrumsetWave(i.drumsetPitch);const o=Y.drumsetIndexReferenceDelta(i.drumsetPitch);let l=i.phaseDeltas[0]/o;const u=+i.phaseDeltaScales[0];let c=+i.expression;const f=+i.expressionDelta,p=i.noteFilters,m=0|i.noteFilterCount;let d=+i.initialNoteFilterInput1,M=+i.initialNoteFilterInput2;const S=et.applyFilters;let b=i.phases[0]%1*e.spectrumNoiseLength;0==i.phases[0]&&(b=et.findRandomZeroCrossing(a,e.spectrumNoiseLength)+l);const y=e.spectrumNoiseLength-1,v=s+n;for(let t=s;t<v;t++){const e=0|b,s=e&y;let n=a[s];const i=b-e;n+=(a[s+1]-n)*i;const h=n,o=S(h,d,M,m,p);M=d,d=h,b+=l,l*=u;const v=o*c;c+=f,r[t]+=v}i.phases[0]=b/e.spectrumNoiseLength,i.phaseDeltas[0]=l*o,i.expression=c,t.sanitizeFilters(p),i.initialNoteFilterInput1=d,i.initialNoteFilterInput2=M}static findRandomZeroCrossing(t,e){let s=Math.random()*e;const n=e-1;let i=s&n,h=t[i];for(let r=128;r>0;r--){const r=i+16&n,a=t[r];if(h*a<=0){for(let r=0;r<16;r++){const r=i+1&n,a=t[r];if(h*a<=0){const t=a-h;s=i,Math.abs(t)>1e-8&&(s+=-h/t),s=Math.max(0,s)%e;break}i=r,h=a}break}i=r,h=a}return s}static instrumentVolumeToVolumeMult(t){return t==e.volumeRange-1?0:Math.pow(2,e.volumeLogScale*t)}static volumeMultToInstrumentVolume(t){return t<=0?e.volumeRange-1:Math.min(e.volumeRange-2,Math.log2(t)/e.volumeLogScale)}static noteSizeToVolumeMult(t){return Math.pow(Math.max(0,t)/e.noteSizeMax,1.5)}static volumeMultToNoteSize(t){return Math.pow(Math.max(0,t),1/1.5)*e.noteSizeMax}static fadeInSettingToSeconds(t){return.0125*(.95*t+.05*t*t)}static secondsToFadeInSetting(t){return L(0,e.fadeInRange,Math.round((-.95+Math.sqrt(.9025+.2*t/.0125))/.1))}static fadeOutSettingToTicks(t){return e.fadeOutTicks[t]}static ticksToFadeOutSetting(t){let s=e.fadeOutTicks[0];if(t<=s)return 0;for(let n=1;n<e.fadeOutTicks.length;n++){let i=e.fadeOutTicks[n];if(t<=i)return t<(s+i)/2?n-1:n;s=i}return e.fadeOutTicks.length-1}static detuneToCents(t){return t*(Math.abs(t)+1)/2}static centsToDetune(t){return Math.sign(t)*(Math.sqrt(1+8*Math.abs(t))-1)/2}getSamplesPerTick(){if(null==this.song)return 0;const t=this.song.getBeatsPerMinute()/60,s=e.partsPerBeat*t,n=e.ticksPerPart*s;return this.samplesPerSecond/n}static fittingPowerOfTwo(t){return 1<<32-Math.clz32(Math.ceil(t)-1)}sanitizeFilters(t){let e=!1;for(const s of t){const t=Math.abs(s.output1),n=Math.abs(s.output2);if(!(t<100&&n<100)){e=!0;break}t<O&&(s.output1=0),n<O&&(s.output2=0)}if(e)for(const e of t)e.output1=0,e.output2=0}static sanitizeDelayLine(t,e,s){for(;;){const n=--e&s,i=Math.abs(t[n]);if(Number.isFinite(i)&&(0==i||i>=O))break;t[n]=0}}static applyFilters(t,e,s,n,i){for(let h=0;h<n;h++){const n=i[h],r=n.output1,a=n.output2,o=n.a1,l=n.a2,u=n.b0,c=n.b1,f=n.b2;t=u*t+c*e+f*s-o*r-l*a,n.a1=o+n.a1Delta,n.a2=l+n.a2Delta,n.useMultiplicativeInputCoefficients?(n.b0=u*n.b0Delta,n.b1=c*n.b1Delta,n.b2=f*n.b2Delta):(n.b0=u+n.b0Delta,n.b1=c+n.b1Delta,n.b2=f+n.b2Delta),n.output2=r,n.output1=t,s=a,e=r}return t}}return et.tempFilterStartCoefficients=new F,et.tempFilterEndCoefficients=new F,et.fmSynthFunctionCache={},et.effectsFunctionCache=Array(128).fill(void 0),et.pickedStringFunctionCache=Array(3).fill(void 0),et.fmSourceTemplate=("\n\t\tconst data = synth.tempMonoInstrumentSampleBuffer;\n\t\tconst sineWave = Config.sineWave;\n\t\t\n\t\t// I'm adding 1000 to the phase to ensure that it's never negative even when modulated by other waves because negative numbers don't work with the modulus operator very well.\n\t\tlet operator#Phase       = +((tone.phases[#] % 1) + 1000) * "+e.sineWaveLength+";\n\t\tlet operator#PhaseDelta  = +tone.phaseDeltas[#] * "+e.sineWaveLength+";\n\t\tlet operator#PhaseDeltaScale = +tone.phaseDeltaScales[#];\n\t\tlet operator#OutputMult  = +tone.operatorExpressions[#];\n\t\tconst operator#OutputDelta = +tone.operatorExpressionDeltas[#];\n\t\tlet operator#Output      = +tone.feedbackOutputs[#];\n\t\tlet feedbackMult         = +tone.feedbackMult;\n\t\tconst feedbackDelta      = +tone.feedbackDelta;\n\t\tlet expression = +tone.expression;\n\t\tconst expressionDelta = +tone.expressionDelta;\n\t\t\n\t\tconst filters = tone.noteFilters;\n\t\tconst filterCount = tone.noteFilterCount|0;\n\t\tlet initialFilterInput1 = +tone.initialNoteFilterInput1;\n\t\tlet initialFilterInput2 = +tone.initialNoteFilterInput2;\n\t\tconst applyFilters = Synth.applyFilters;\n\t\t\n\t\tconst stopIndex = bufferIndex + runLength;\n\t\tfor (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\n\t\t\t// INSERT OPERATOR COMPUTATION HERE\n\t\t\tconst fmOutput = (/*operator#Scaled*/); // CARRIER OUTPUTS\n\t\t\t\n\t\t\tconst inputSample = fmOutput;\n\t\t\tconst sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\n\t\t\tinitialFilterInput2 = initialFilterInput1;\n\t\t\tinitialFilterInput1 = inputSample;\n\t\t\t\n\t\t\tfeedbackMult += feedbackDelta;\n\t\t\toperator#OutputMult += operator#OutputDelta;\n\t\t\toperator#Phase += operator#PhaseDelta;\n\t\t\toperator#PhaseDelta *= operator#PhaseDeltaScale;\n\t\t\t\n\t\t\tconst output = sample * expression;\n\t\t\texpression += expressionDelta;\n\t\t\t\n\t\t\tdata[sampleIndex] += output;\n\t\t}\n\t\t\n\t\ttone.phases[#] = operator#Phase / "+e.sineWaveLength+";\n\t\ttone.phaseDeltas[#] = operator#PhaseDelta / "+e.sineWaveLength+";\n\t\ttone.operatorExpressions[#] = operator#OutputMult;\n\t\ttone.feedbackOutputs[#] = operator#Output;\n\t\ttone.feedbackMult = feedbackMult;\n\t\ttone.expression = expression;\n\t\t\n\t\tsynth.sanitizeFilters(filters);\n\t\ttone.initialNoteFilterInput1 = initialFilterInput1;\n\t\ttone.initialNoteFilterInput2 = initialFilterInput2;\n\t").split("\n"),et.operatorSourceTemplate=("\n\t\t\tconst operator#PhaseMix = operator#Phase/* + operator@Scaled*/;\n\t\t\tconst operator#PhaseInt = operator#PhaseMix|0;\n\t\t\tconst operator#Index    = operator#PhaseInt & "+e.sineWaveMask+";\n\t\t\tconst operator#Sample   = sineWave[operator#Index];\n\t\t\toperator#Output         = operator#Sample + (sineWave[operator#Index + 1] - operator#Sample) * (operator#PhaseMix - operator#PhaseInt);\n\t\t\tconst operator#Scaled   = operator#OutputMult * operator#Output;\n\t").split("\n"),t.Channel=_,t.Config=e,t.EnvelopeSettings=H,t.FilterControlPoint=U,t.FilterSettings=K,t.HarmonicsWave=q,t.Instrument=J,t.Note=E,t.Operator=z,t.Pattern=V,t.Song=$,t.SpectrumWave=W,t.Synth=et,t.clamp=L,t.makeNotePin=N,Object.defineProperty(t,"V",{value:!0}),t}({});
//# sourceMappingURL=beepbox_synth.min.js.map