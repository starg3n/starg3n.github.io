{
  "version": 3,
  "sources": ["../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/rng.js", "../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/stringify.js", "../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/native.js", "../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v4.js", "../node_modules/.pnpm/@mercuryworkshop+bare-mux@1.1.1/node_modules/@mercuryworkshop/bare-mux/src/BareTypes.ts", "../node_modules/.pnpm/@mercuryworkshop+bare-mux@1.1.1/node_modules/@mercuryworkshop/bare-mux/src/snapshot.ts", "../node_modules/.pnpm/@mercuryworkshop+bare-mux@1.1.1/node_modules/@mercuryworkshop/bare-mux/src/RemoteClient.ts", "../node_modules/.pnpm/@mercuryworkshop+bare-mux@1.1.1/node_modules/@mercuryworkshop/bare-mux/src/Switcher.ts", "../node_modules/.pnpm/@mercuryworkshop+bare-mux@1.1.1/node_modules/@mercuryworkshop/bare-mux/src/webSocket.ts", "../node_modules/.pnpm/@mercuryworkshop+bare-mux@1.1.1/node_modules/@mercuryworkshop/bare-mux/src/BareClient.ts", "../src/worker/index.ts"],
  "sourcesContent": ["// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}", "import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;", "const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;", "export type BareHeaders = Record<string, string | string[]>;\n\nexport type BareMeta =\n  {\n    // ???\n  };\n\nexport type TransferrableResponse =\n  {\n    body: ReadableStream | ArrayBuffer | Blob | string,\n    headers: BareHeaders,\n    status: number,\n    statusText: string\n  }\n\nexport interface BareTransport {\n  init: () => Promise<void>;\n  ready: boolean;\n  connect: (\n    url: URL,\n    origin: string,\n    protocols: string[],\n    requestHeaders: BareHeaders,\n    onopen: (protocol: string) => void,\n    onmessage: (data: Blob | ArrayBuffer | string) => void,\n    onclose: (code: number, reason: string) => void,\n    onerror: (error: string) => void,\n  ) => (data: Blob | ArrayBuffer | string) => void;\n\n  request: (\n    remote: URL,\n    method: string,\n    body: BodyInit | null,\n    headers: BareHeaders,\n    signal: AbortSignal | undefined\n  ) => Promise<TransferrableResponse>;\n\n  meta: () => BareMeta\n}\nexport interface BareWebSocketMeta {\n  protocol: string;\n  setCookies: string[];\n}\n\nexport type BareHTTPProtocol = 'blob:' | 'http:' | 'https:' | string;\nexport type BareWSProtocol = 'ws:' | 'wss:' | string;\n\nexport const maxRedirects = 20;\n\n\n", "// The user likely has overwritten all networking functions after importing bare-client\n// It is our responsibility to make sure components of Bare-Client are using native networking functions\n\nexport const fetch = globalThis.fetch;\nexport const WebSocket = globalThis.WebSocket;\nexport const Request = globalThis.Request;\nexport const Response = globalThis.Response;\nexport const XMLHttpRequest = globalThis.XMLHttpRequest;\n\nexport const WebSocketFields = {\n  prototype: {\n    send: WebSocket.prototype.send,\n  },\n  CLOSED: WebSocket.CLOSED,\n  CLOSING: WebSocket.CLOSING,\n  CONNECTING: WebSocket.CONNECTING,\n  OPEN: WebSocket.OPEN,\n};\n", "/// <reference lib=\"WebWorker\" />\nimport { v4 as uuid } from 'uuid';\nimport { BareHeaders, BareTransport, TransferrableResponse } from './BareTypes';\nimport { findSwitcher } from './Switcher';\n\nexport function registerRemoteListener(channel: ServiceWorker) {\n  (navigator as any).serviceWorker.addEventListener(\"message\", async ({ data }) => {\n    if (data.type === \"request\") {\n      const { remote, method, body, headers } = data;\n\n      let response: any = await findSwitcher().active?.request(new URL(remote), method, body, headers, undefined)!.catch((err) => {\n        let error = { id: data.id, type: \"error\", error: err}\n        console.error(err)\n        channel.postMessage(error);\n      });\n      if (response) {\n        let transferred: any = [];\n        if (response.body instanceof ArrayBuffer || response.body instanceof Blob || response.body instanceof ReadableStream) {\n          transferred.push(response.body);\n        }\n        response.id = data.id;\n        response.type = \"response\";\n        channel.postMessage(response, transferred);\n      }\n    }\n  });\n}\n\ndeclare var self: ServiceWorkerGlobalScope;\nlet remote: RemoteTransport;\nif (\"ServiceWorkerGlobalScope\" in self) {\n  addEventListener(\"message\", async ({ data }) => {\n    if (data.type === \"response\") {\n      let promise = remote.promises.get(data.id) as any;\n      if (promise!.resolve) {\n        promise!.resolve(data);\n        remote.promises.delete(data.id);\n      }\n    } else if (data.type === \"error\") {\n      let promise = remote.promises.get(data.id) as any;\n      if (promise!.reject) {\n        promise!.reject(data.error);\n        remote.promises.delete(data.id);\n      }\n    }\n  });\n}\n\nexport default class RemoteTransport implements BareTransport {\n  canstart = true;\n  ready = false;\n  promises = new Map<string, (data: any) => void>();\n  constructor() {\n    if (!(\"ServiceWorkerGlobalScope\" in self)) {\n      throw new TypeError(\"Attempt to construct RemoteClient from outside a service worker\")\n    }\n  }\n\n  async init() {\n    remote = this;\n    this.ready = true;\n  }\n\n  async meta() { }\n  async request(\n    remote: URL,\n    method: string,\n    body: BodyInit | null,\n    headers: BareHeaders,\n    signal: AbortSignal | undefined\n  ): Promise<TransferrableResponse> {\n    let id = uuid();\n    const clients = await self.clients.matchAll();\n    if (clients.length < 1)\n      throw new Error(\"no available clients\");\n\n    for (const client of clients) {\n      client.postMessage({\n        type: \"request\",\n        id,\n        remote: remote.toString(),\n        method,\n        body,\n        headers\n      });\n    }\n\n\n    return await new Promise((resolve, reject) => {\n      this.promises.set(id, { resolve, reject } as any);\n    });\n  }\n\n  connect(\n    url: URL,\n    origin: string,\n    protocols: string[],\n    requestHeaders: BareHeaders,\n    onopen: (protocol: string) => void,\n    onmessage: (data: Blob | ArrayBuffer | string) => void,\n    onclose: (code: number, reason: string) => void,\n    onerror: (error: string) => void\n  ): (data: Blob | ArrayBuffer | string) => void {\n    throw \"why are you calling connect from remoteclient\"\n  }\n}", "import { BareTransport } from \"./BareTypes\";\nimport RemoteTransport from \"./RemoteClient\";\n\n//@ts-expect-error not installing node types for this one thing\nself.BCC_VERSION = process.env.BARE_MUX_VERSION;\nconsole.debug(\"BARE_MUX_VERSION: \" + self.BCC_VERSION);\n\ndeclare global {\n  interface ServiceWorkerGlobalScope {\n    gSwitcher: Switcher;\n    BCC_VERSION: string;\n    BCC_DEBUG: boolean;\n  }\n  interface WorkerGlobalScope {\n    gSwitcher: Switcher;\n    BCC_VERSION: string;\n    BCC_DEBUG: boolean;\n  }\n  interface Window {\n    gSwitcher: Switcher;\n    BCC_VERSION: string;\n    BCC_DEBUG: boolean;\n  }\n}\n\nfunction initTransport(name: string, config: any) {\n  let cl = new ((0, eval)(name))(...config);\n  cl.initpromise = cl.init();\n  return cl;\n}\nclass Switcher {\n  active: BareTransport | null = null\n\n  channel = new BroadcastChannel(\"bare-mux\");\n\n  data: Object | null = null\n\n  constructor() {\n    this.channel.addEventListener(\"message\", ({ data: { type, data } }) => {\n      console.log(`bare-mux: ${type}`, data, `${\"ServiceWorker\" in globalThis}`);\n      switch (type) {\n        case \"setremote\":\n          this.active = new RemoteTransport\n          break;\n        case \"set\":\n          const { name, config } = data;\n          this.active = initTransport(name, config);\n          break;\n        case \"find\":\n          if (this.data) { \n            this.channel.postMessage(this.data)\n          }\n          break;\n      }\n    });\n  }\n}\n\nexport function findSwitcher(): Switcher {\n  if (\"ServiceWorkerGlobalScope\" in globalThis && globalThis.gSwitcher && !globalThis.gSwitcher.active) {\n    globalThis.gSwitcher.channel.postMessage({ type: \"find\" })\n  }\n  if (globalThis.gSwitcher) return globalThis.gSwitcher;\n  if (\"ServiceWorkerGlobalScope\" in globalThis) {\n    globalThis.gSwitcher = new Switcher;\n    globalThis.gSwitcher.channel.postMessage({ type: \"find\" })\n    return globalThis.gSwitcher;\n  }\n\n  let _parent: any = window;\n  for (let i = 0; i < 20; i++) {\n    try {\n      if (_parent == _parent.parent) {\n        globalThis.gSwitcher = new Switcher;\n        return globalThis.gSwitcher;\n      }\n      _parent = _parent.parent;\n\n      if (_parent && _parent[\"gSwitcher\"]) {\n        console.debug(\"Found implementation on parent\");\n        globalThis.gSwitcher = _parent[\"gSwitcher\"];\n        return _parent[\"gSwitcher\"];\n      }\n    } catch (e) {\n      globalThis.gSwitcher = new Switcher;\n      globalThis.gSwitcher.channel.postMessage({ type: \"find\" })\n      return globalThis.gSwitcher;\n    }\n  }\n\n  throw \"unreachable\";\n}\nfindSwitcher();\n\nexport function SetTransport(name: string, ...config: any[]) {\n  let switcher = findSwitcher();\n  switcher.active = initTransport(name, config);\n  switcher.data = { type: \"set\", data: { name, config } }\n  switcher.channel.postMessage(switcher.data);\n}\n\nexport async function SetSingletonTransport(client: BareTransport) {\n  let switcher = findSwitcher();\n  await client.init();\n  switcher.active = client;\n  switcher.data = { type: \"setremote\", data: { name: client.constructor.name }}\n  switcher.channel.postMessage(switcher.data);\n}\n", "/*\n * WebSocket helpers\n */\n\nconst validChars =\n  \"!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~\";\n\nexport function validProtocol(protocol: string): boolean {\n  for (let i = 0; i < protocol.length; i++) {\n    const char = protocol[i];\n\n    if (!validChars.includes(char)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import { BareHeaders, maxRedirects } from './BareTypes';\nimport { findSwitcher } from './Switcher';\nimport { WebSocketFields } from './snapshot.js';\nimport { validProtocol } from './webSocket';\n\n\n// get the unhooked value\nconst getRealReadyState = Object.getOwnPropertyDescriptor(\n  WebSocket.prototype,\n  'readyState'\n)!.get!;\n\nconst wsProtocols = ['ws:', 'wss:'];\nconst statusEmpty = [101, 204, 205, 304];\n\nconst statusRedirect = [301, 302, 303, 307, 308];\n\nexport type WebSocketImpl = {\n  new(...args: ConstructorParameters<typeof WebSocket>): WebSocket;\n};\n\nexport namespace BareWebSocket {\n  export type GetReadyStateCallback = () => number;\n  export type GetSendErrorCallback = () => Error | undefined;\n  export type GetProtocolCallback = () => string;\n  export type HeadersType = BareHeaders | Headers | undefined;\n  export type HeadersProvider =\n    | BareHeaders\n    | (() => BareHeaders | Promise<BareHeaders>);\n\n  export interface Options {\n    /**\n     * A provider of request headers to pass to the remote.\n     * Usually one of `User-Agent`, `Origin`, and `Cookie`\n     * Can be just the headers object or an synchronous/asynchronous function that returns the headers object\n     */\n    headers?: BareWebSocket.HeadersProvider;\n    /**\n     * A hook executed by this function with helper arguments for hooking the readyState property. If a hook isn't provided, bare-client will hook the property on the instance. Hooking it on an instance basis is good for small projects, but ideally the class should be hooked by the user of bare-client.\n     */\n    readyStateHook?:\n    | ((\n      socket: WebSocket,\n      getReadyState: BareWebSocket.GetReadyStateCallback\n    ) => void)\n    | undefined;\n    /**\n     * A hook executed by this function with helper arguments for determining if the send function should throw an error. If a hook isn't provided, bare-client will hook the function on the instance.\n     */\n    sendErrorHook?:\n    | ((\n      socket: WebSocket,\n      getSendError: BareWebSocket.GetSendErrorCallback\n    ) => void)\n    | undefined;\n    /**\n     * A hook executed by this function with the URL. If a hook isn't provided, bare-client will hook the URL.\n     */\n    urlHook?: ((socket: WebSocket, url: URL) => void) | undefined;\n    /**\n     * A hook executed by this function with a helper for getting the current fake protocol. If a hook isn't provided, bare-client will hook the protocol.\n     */\n    protocolHook?:\n    | ((\n      socket: WebSocket,\n      getProtocol: BareWebSocket.GetProtocolCallback\n    ) => void)\n    | undefined;\n    /**\n     * A callback executed by this function with an array of cookies. This is called once the metadata from the server is received.\n     */\n    setCookiesCallback?: ((setCookies: string[]) => void) | undefined;\n    webSocketImpl?: WebSocket;\n  }\n}\n\n/**\n * A Response with additional properties.\n */\nexport interface BareResponse extends Response {\n  rawResponse: Response;\n  rawHeaders: BareHeaders;\n}\n/**\n * A BareResponse with additional properties.\n */\nexport interface BareResponseFetch extends BareResponse {\n  finalURL: string;\n}\nexport class BareClient {\n\n  /**\n   * Create a BareClient. Calls to fetch and connect will wait for an implementation to be ready.\n   */\n  constructor() { }\n\n  createWebSocket(\n    remote: string | URL,\n    protocols: string | string[] | undefined = [],\n    webSocketImpl: WebSocketImpl,\n    requestHeaders: BareHeaders,\n    arrayBufferImpl: typeof ArrayBuffer,\n  ): WebSocket {\n    let switcher = findSwitcher();\n    let client = switcher.active;\n    if (!client) throw \"invalid switcher\";\n\n    if (!client.ready)\n      throw new TypeError(\n        'You need to wait for the client to finish fetching the manifest before creating any WebSockets. Try caching the manifest data before making this request.'\n      );\n\n    try {\n      remote = new URL(remote);\n    } catch (err) {\n      throw new DOMException(\n        `Faiiled to construct 'WebSocket': The URL '${remote}' is invalid.`\n      );\n    }\n\n    if (!wsProtocols.includes(remote.protocol))\n      throw new DOMException(\n        `Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${remote.protocol}' is not allowed.`\n      );\n\n    if (!Array.isArray(protocols)) protocols = [protocols];\n\n    protocols = protocols.map(String);\n\n    for (const proto of protocols)\n      if (!validProtocol(proto))\n        throw new DOMException(\n          `Failed to construct 'WebSocket': The subprotocol '${proto}' is invalid.`\n        );\n\n\n    let wsImpl = (webSocketImpl || WebSocket) as WebSocketImpl;\n    const socket = new wsImpl(\"ws://127.0.0.1:1\", protocols);\n\n    let fakeProtocol = '';\n\n    let fakeReadyState: number = WebSocketFields.CONNECTING;\n\n    let initialErrorHappened = false;\n    socket.addEventListener(\"error\", (e) => {\n      if (!initialErrorHappened) {\n        fakeReadyState = WebSocket.CONNECTING;\n        e.stopImmediatePropagation();\n        initialErrorHappened = true;\n      }\n    });\n    let initialCloseHappened = false;\n    socket.addEventListener(\"close\", (e) => {\n      if (!initialCloseHappened) {\n        e.stopImmediatePropagation();\n        initialCloseHappened = true;\n      }\n    });\n    // TODO socket onerror will be broken\n\n    arrayBufferImpl = arrayBufferImpl || webSocketImpl.constructor.constructor(\"return ArrayBuffer\")().prototype;\n    requestHeaders['Host'] = (new URL(remote)).host;\n    // requestHeaders['Origin'] = origin;\n    requestHeaders['Pragma'] = 'no-cache';\n    requestHeaders['Cache-Control'] = 'no-cache';\n    requestHeaders['Upgrade'] = 'websocket';\n    // requestHeaders['User-Agent'] = navigator.userAgent;\n    requestHeaders['Connection'] = 'Upgrade';\n    const sendData = client.connect(\n      remote,\n      origin,\n      protocols,\n      requestHeaders,\n      (protocol: string) => {\n        fakeReadyState = WebSocketFields.OPEN;\n        fakeProtocol = protocol;\n\n        (socket as any).meta = {\n          headers: {\n            \"sec-websocket-protocol\": protocol,\n          }\n        }; // what the fuck is a meta\n        socket.dispatchEvent(new Event(\"open\"));\n      },\n      async (payload) => {\n        if (typeof payload === \"string\") {\n          socket.dispatchEvent(new MessageEvent(\"message\", { data: payload }));\n        } else if (\"byteLength\" in payload) {\n          if (socket.binaryType === \"blob\") {\n            payload = new Blob([payload]);\n          } else {\n            Object.setPrototypeOf(payload, arrayBufferImpl);\n          }\n\n          socket.dispatchEvent(new MessageEvent(\"message\", { data: payload }));\n        } else if (\"arrayBuffer\" in payload) {\n          if (socket.binaryType === \"arraybuffer\") {\n            payload = await payload.arrayBuffer()\n            Object.setPrototypeOf(payload, arrayBufferImpl);\n          }\n\n          socket.dispatchEvent(new MessageEvent(\"message\", { data: payload }));\n        }\n      },\n      (code, reason) => {\n        fakeReadyState = WebSocketFields.CLOSED;\n        socket.dispatchEvent(new CloseEvent(\"close\", { code, reason }));\n      },\n      () => {\n        fakeReadyState = WebSocketFields.CLOSED;\n      },\n    )\n\n    // protocol is always an empty before connecting\n    // updated when we receive the metadata\n    // this value doesn't change when it's CLOSING or CLOSED etc\n    const getReadyState = () => fakeReadyState;\n\n    // we have to hook .readyState ourselves\n\n    Object.defineProperty(socket, 'readyState', {\n      get: getReadyState,\n      configurable: true,\n      enumerable: true,\n    });\n\n    /**\n     * @returns The error that should be thrown if send() were to be called on this socket according to the fake readyState value\n     */\n    const getSendError = () => {\n      const readyState = getReadyState();\n\n      if (readyState === WebSocketFields.CONNECTING)\n        return new DOMException(\n          \"Failed to execute 'send' on 'WebSocket': Still in CONNECTING state.\"\n        );\n    };\n\n    // we have to hook .send ourselves\n    // use ...args to avoid giving the number of args a quantity\n    // no arguments will trip the following error: TypeError: Failed to execute 'send' on 'WebSocket': 1 argument required, but only 0 present.\n    socket.send = function(...args) {\n      const error = getSendError();\n\n      if (error) throw error;\n      sendData(args[0] as any);\n    };\n\n    Object.defineProperty(socket, 'url', {\n      get: () => remote.toString(),\n      configurable: true,\n      enumerable: true,\n    });\n\n    const getProtocol = () => fakeProtocol;\n\n    Object.defineProperty(socket, 'protocol', {\n      get: getProtocol,\n      configurable: true,\n      enumerable: true,\n    });\n\n    return socket;\n  }\n\n  async fetch(\n    url: string | URL,\n    init?: RequestInit\n  ): Promise<BareResponseFetch> {\n    // Only create an instance of Request to parse certain parameters of init such as method, headers, redirect\n    // But use init values whenever possible\n    const req = new Request(url, init);\n\n\n    // try to use init.headers because it may contain capitalized headers\n    // furthermore, important headers on the Request class are blocked...\n    // we should try to preserve the capitalization due to quirks with earlier servers\n    const inputHeaders = init?.headers || req.headers;\n\n    const headers: BareHeaders =\n      inputHeaders instanceof Headers\n        ? Object.fromEntries(inputHeaders)\n        : (inputHeaders as BareHeaders);\n\n\n    const body = init?.body || req.body;\n\n    let urlO = new URL(req.url);\n\n    if (urlO.protocol.startsWith('blob:')) {\n      const response = await fetch(urlO);\n      const result: Response & Partial<BareResponse> = new Response(\n        response.body,\n        response\n      );\n\n      result.rawHeaders = Object.fromEntries(response.headers);\n      result.rawResponse = response;\n\n      return result as BareResponseFetch;\n    }\n\n    let switcher = findSwitcher();\n    if (!switcher.active) {\n      // in race conditions we trust\n      await new Promise(r => setTimeout(r, 1000));\n      switcher = findSwitcher();\n    };\n    if (!switcher.active) throw \"there are no bare clients\";\n    const client = switcher.active;\n    if (!client.ready) await client.init();\n\n    for (let i = 0; ; i++) {\n      if ('host' in headers) headers.host = urlO.host;\n      else headers.Host = urlO.host;\n\n\n      let resp = await client.request(\n        urlO,\n        req.method,\n        body,\n        headers,\n        req.signal\n      );\n\n      let responseobj: BareResponse & Partial<BareResponseFetch> = new Response(\n        statusEmpty.includes(resp.status) ? undefined : resp.body, {\n        headers: new Headers(resp.headers as HeadersInit),\n        status: resp.status,\n        statusText: resp.statusText,\n      }) as BareResponse;\n      responseobj.rawHeaders = resp.headers;\n      responseobj.rawResponse = new Response(resp.body);\n\n\n      responseobj.finalURL = urlO.toString();\n\n      const redirect = init?.redirect || req.redirect;\n\n      if (statusRedirect.includes(responseobj.status)) {\n        switch (redirect) {\n          case 'follow': {\n            const location = responseobj.headers.get('location');\n            if (maxRedirects > i && location !== null) {\n              urlO = new URL(location, urlO);\n              continue;\n            } else throw new TypeError('Failed to fetch');\n          }\n          case 'error':\n            throw new TypeError('Failed to fetch');\n          case 'manual':\n            return responseobj as BareResponseFetch;\n        }\n      } else {\n        return responseobj as BareResponseFetch;\n      }\n    }\n  }\n}\n", "import { BareClient } from \"@mercuryworkshop/bare-mux\";\r\nimport { BareResponseFetch } from \"@mercuryworkshop/bare-mux\"\r\n\r\ndeclare global {\r\n    interface Window {\r\n        ScramjetServiceWorker;\r\n    }\r\n}\r\n\r\nself.ScramjetServiceWorker = class ScramjetServiceWorker {\r\n    client: typeof BareClient.prototype;\r\n    config: typeof self.__scramjet$config;\r\n    constructor(config = self.__scramjet$config) {\r\n        this.client = new BareClient();\r\n        if (!config.prefix) config.prefix = \"/scramjet/\";\r\n        this.config = config;\r\n    }\r\n\r\n    route({ request }: FetchEvent) {\r\n        if (request.url.startsWith(location.origin + this.config.prefix)) return true;\r\n        else return false;\r\n    }\r\n\r\n    async fetch({ request }: FetchEvent) {\r\n        const urlParam = new URLSearchParams(new URL(request.url).search);\r\n\r\n        if (urlParam.has(\"url\")) {\r\n            return Response.redirect(self.__scramjet$bundle.rewriters.url.encodeUrl(urlParam.get(\"url\"), new URL(urlParam.get(\"url\"))))\r\n        }\r\n\r\n        try {\r\n            const url = new URL(self.__scramjet$bundle.rewriters.url.decodeUrl(request.url));\r\n\r\n            const response: BareResponseFetch = await this.client.fetch(url, {\r\n                method: request.method,\r\n                body: request.body,\r\n                headers: request.headers,\r\n                credentials: \"omit\",\r\n                mode: request.mode === \"cors\" ? request.mode : \"same-origin\",\r\n                cache: request.cache,\r\n                redirect: request.redirect,\r\n            });\r\n\r\n            let responseBody;\r\n            const responseHeaders = self.__scramjet$bundle.rewriters.rewriteHeaders(response.rawHeaders, url);\r\n            if (response.body) {\r\n                switch (request.destination) {\r\n                case \"iframe\":\r\n                case \"document\":\r\n                    responseBody = self.__scramjet$bundle.rewriters.rewriteHtml(await response.text(), url);\r\n                    break;\r\n                case \"script\":\r\n                    responseBody = self.__scramjet$bundle.rewriters.rewriteJs(await response.text(), url);\r\n                    break;\r\n                case \"style\":\r\n                    responseBody = self.__scramjet$bundle.rewriters.rewriteCss(await response.text(), url);\r\n                    break;\r\n                case \"sharedworker\":\r\n                    break;\r\n                case \"worker\":\r\n                    break;\r\n                default:\r\n                    responseBody = response.body;\r\n                    break;\r\n                }\r\n            }\r\n            // downloads\r\n            if (request.destination === \"document\") {\r\n                const header = responseHeaders[\"content-disposition\"];\r\n\r\n                // validate header and test for filename\r\n                if (!/\\s*?((inline|attachment);\\s*?)filename=/i.test(header)) {\r\n                    // if filename= wasn\"t specified then maybe the remote specified to download this as an attachment?\r\n                    // if it\"s invalid then we can still possibly test for the attachment/inline type\r\n                    const type = /^\\s*?attachment/i.test(header)\r\n                        ? \"attachment\"\r\n                        : \"inline\";\r\n\r\n                    // set the filename\r\n                    const [filename] = new URL(response.finalURL).pathname\r\n                        .split(\"/\")\r\n                        .slice(-1);\r\n\r\n                    responseHeaders[\r\n                        \"content-disposition\"\r\n                    ] = `${type}; filename=${JSON.stringify(filename)}`;\r\n                }\r\n            }\r\n            if (responseHeaders[\"accept\"] === \"text/event-stream\") {\r\n                responseHeaders[\"content-type\"] = \"text/event-stream\";\r\n            }\r\n            if (crossOriginIsolated) {\r\n                responseHeaders[\"Cross-Origin-Embedder-Policy\"] = \"require-corp\";\r\n            }\r\n\r\n            return new Response(responseBody, {\r\n                headers: responseHeaders as HeadersInit,\r\n                status: response.status,\r\n                statusText: response.statusText\r\n            })\r\n        } catch (err) {\r\n            if (![\"document\", \"iframe\"].includes(request.destination))\r\n                return new Response(undefined, { status: 500 });\r\n            \r\n            console.error(err);\r\n\r\n            return renderError(err, self.__scramjet$bundle.rewriters.url.decodeUrl(request.url));\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction errorTemplate(\r\n    trace: string,\r\n    fetchedURL: string,\r\n) {\r\n    // turn script into a data URI so we don\"t have to escape any HTML values\r\n    const script = `\r\n        errorTrace.value = ${JSON.stringify(trace)};\r\n        fetchedURL.textContent = ${JSON.stringify(fetchedURL)};\r\n        for (const node of document.querySelectorAll(\"#hostname\")) node.textContent = ${JSON.stringify(\r\n        location.hostname\r\n    )};\r\n        reload.addEventListener(\"click\", () => location.reload());\r\n        version.textContent = \"0.0.1\";\r\n    `\r\n\r\n    return (\r\n        `<!DOCTYPE html>\r\n        <html>\r\n        <head>\r\n        <meta charset=\"utf-8\" />\r\n        <title>Error</title>\r\n        <style>\r\n        * { background-color: white }\r\n        </style>\r\n        </head>\r\n        <body>\r\n        <h1 id=\"errorTitle\">Error processing your request</h1>\r\n        <hr />\r\n        <p>Failed to load <b id=\"fetchedURL\"></b></p>\r\n        <p id=\"errorMessage\">Internal Server Error</p>\r\n        <textarea id=\"errorTrace\" cols=\"40\" rows=\"10\" readonly></textarea>\r\n        <p>Try:</p>\r\n        <ul>\r\n        <li>Checking your internet connection</li>\r\n        <li>Verifying you entered the correct address</li>\r\n        <li>Clearing the site data</li>\r\n        <li>Contacting <b id=\"hostname\"></b>\"s administrator</li>\r\n        <li>Verify the server isn\"t censored</li>\r\n        </ul>\r\n        <p>If you\"re the administrator of <b id=\"hostname\"></b>, try:</p>\r\n        <ul>\r\n        <li>Restarting your server</li>\r\n        <li>Updating Scramjet</li>\r\n        <li>Troubleshooting the error on the <a href=\"https://github.com/MercuryWorkshop/scramjet\" target=\"_blank\">GitHub repository</a></li>\r\n        </ul>\r\n        <button id=\"reload\">Reload</button>\r\n        <hr />\r\n        <p><i>Scramjet v<span id=\"version\"></span></i></p>\r\n        <script src=\"${\r\n        \"data:application/javascript,\" + encodeURIComponent(script)\r\n        }\"></script>\r\n        </body>\r\n        </html>\r\n        `\r\n    );\r\n}\r\n\r\n/**\r\n *\r\n * @param {unknown} err\r\n * @param {string} fetchedURL\r\n */\r\nfunction renderError(err, fetchedURL) {\r\n    const headers = {\r\n        \"content-type\": \"text/html\",\r\n    };\r\n    if (crossOriginIsolated) {\r\n        headers[\"Cross-Origin-Embedd'er-Policy\"] = \"require-corp\";\r\n    }\r\n\r\n    return new Response(\r\n        errorTemplate(\r\n            String(err),\r\n            fetchedURL\r\n        ),\r\n        {\r\n            status: 500,\r\n            headers: headers\r\n        }\r\n    );\r\n}\r\n\r\n"],
  "mappings": "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",
  "names": ["Response", "remote", "uuid", "origin", "remote", "Response", "location"]
}
